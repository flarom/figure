<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Figure - VRM Model Viewer</title>
	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<link rel="stylesheet" href="style/palette.css">
	<link rel="stylesheet" href="style/share.css">
	<link rel="stylesheet" href="style/prompts.css">
	<link rel="shortcut icon" href="static/favicon.svg" type="image/x-icon">
</head>

<body class="theme-light">
	<header class="window-title bottom">
		<div class="header-left">
			<button class="icon-button" translate="no" onmousedown="toggleSidebar('controls-bar')"
				title="Toggle sidebar">side_navigation</button>
			<button id="openFileBtn" class="icon-button" translate="no" title="Open model">folder_open</button>
		</div>
		<div class="header-center hide-on-mobile">
			<div id="vrm-model-name">Figure</div>
			<span id="vrm-author-name">Currently loading</span>
		</div>
		<div class="header-right">
			<button class="icon-button" translate="no" id="playPauseBtn" title="Play / Pause animation (P)" disabled>play_arrow</button>
			<hr>
			<button class="icon-button" translate="no" id="stopBtn" title="Stop animation" disabled>accessibility</button>
			<button class="icon-button" translate="no" id="resetCameraBtn" title="Reset camera (R)">refresh</button>
			<hr>
			<div class="dropdown">
				<button class="icon-button" translate="no" onmousedown="toggleDropdown('more-menu')">more_vert</button>
				<div class="dropdown-content menu" id="more-menu">
					<button class="text-button" onmouseup="showMessageFromFile('dialog/about.html'); hideAllMenus()">
						<span>About Figure</span>
						<kbd>F1</kbd>
					</button>
				</div>
			</div>
		</div>
	</header>

	<div id="controls-bar" class="sidebar">
		<div class="item-group">
			<div id="modelInfo">
				<div class="item-group-header">
					<div style="display: flex; align-items: center; gap: 6px;">
						<span class="icon item-group-icon">info</span>
						<strong>Model information</strong>
					</div>
				</div>
				<div class="item-group-content collapsed">
				</div>
			</div>
		</div>
		<div class="item-group">
			<div id="vrmaButtons">
					<div class="item-group-header">
						<div style="display: flex; align-items: center; gap: 6px;">
							<span class="icon item-group-icon">directions_walk</span>
							<strong>Animations</strong>
						</div>
					</div>
					<div class="item-group-content collapsed">
					</div>
				</div>
		</div>
		<div class="item-group">
			<div id="blendShapeRanges">
				<div class="item-group-header">
					<div style="display: flex; align-items: center; gap: 6px;">
						<span class="icon item-group-icon">mood</span>
						<strong>Expressions</strong>
					</div>
				</div>
				<div class="item-group-content collapsed">
					
				</div>
			</div>
		</div>
		<div class="item-group">
			<div id="materialsList">
				<div class="item-group-header">
					<div style="display: flex; align-items: center; gap: 6px;">
						<span class="icon item-group-icon">texture</span>
						<strong>Materials</strong>
					</div>
				</div>
				<div class="item-group-content collapsed">
					
				</div>
			</div>
		</div>
	</div>

	<div class="status-bar show" id="status">
		<div class="status-bar-left">
			<span id="status">Loading VRM model...</span>
		</div>
		<div class="status-bar-right"></div>
	</div>

	<div class="main-wrapper" id="mainWrapper" onclick="hideAllMenus();">

	</div>

	<!-- hidden file input for Open model button -->
	<input type="file" id="fileInput" accept=".vrm,.vrma" style="display:none" />

	<script src="script/settings.js"></script>
	<script src="script/prompts.js"></script>
	<script src="script/i18n.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
					"@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
					"@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3/lib/three-vrm-animation.module.min.js"
				}
			}
		</script>

	<script type="module">
		import * as THREE from 'three';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
		import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

		// #region DOM Elements
		// DOM elements
		const vrmaButtonsContainer = document.querySelector('#vrmaButtons .item-group-content');
		const playPauseBtn = document.getElementById('playPauseBtn');
		const stopBtn = document.getElementById('stopBtn');
		const statusDiv = document.getElementById('status');
		const mainWrapper = document.getElementById('mainWrapper');
		const vrmModelName = document.getElementById('vrm-model-name');
		const vrmAuthorName = document.getElementById('vrm-author-name');
		const openFileBtn = document.getElementById('openFileBtn');
		const fileInput = document.getElementById('fileInput');

		attachItemGroupToggles();
		// #endregion DOM Elements

		// Wire Open model button to hidden file input
		if (openFileBtn && fileInput) {
			openFileBtn.addEventListener('click', (e) => {
				e.preventDefault();
				fileInput.click();
			});
			fileInput.addEventListener('change', async (ev) => {
				const f = ev.target.files && ev.target.files[0];
				if (f) await handleFileDrop(f);
				fileInput.value = ''; // reset
			});
		}

		// #region Three.js Setup
		// --- Three.js Setup ---
		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
		mainWrapper.appendChild(renderer.domElement);

		const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
		camera.position.set(0.0, 1.0, 5.0);
		const DEFAULT_CAMERA_POSITION = new THREE.Vector3(0.0, 1.0, 5.0);
		const DEFAULT_CONTROLS_TARGET = new THREE.Vector3(0.0, 1.0, 0.0);

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.screenSpacePanning = true;
		controls.target.copy(DEFAULT_CONTROLS_TARGET);
		controls.update();

		const scene = new THREE.Scene();
		// Use CSS variable `--background-color` for the scene background.
		// Read from `body` (theme class) first, then fall back to `:root`, then a hard fallback.
		const bodyBg = getComputedStyle(document.body).getPropertyValue('--background-color').trim();
		const rootBg = getComputedStyle(document.documentElement).getPropertyValue('--background-color').trim();
		const cssBg = bodyBg || rootBg || '#222222';
		scene.background = new THREE.Color(cssBg);

		const light = new THREE.DirectionalLight(0xffffff, 3.0); // Increased intensity
		light.position.set(0.5, 1.0, 1.0).normalize();
		scene.add(light);

		const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Brighter ambient light
		scene.add(ambientLight);

		// --- Global Variables for VRM and Animation ---
		let currentVrm = undefined;
		let currentMixer = undefined;
		let currentAction = undefined;
		let vrmaAnimationClip = undefined; // Store the final THREE.AnimationClip
		let groundShadow = null;

		const LAST_VRM_KEY = 'vrmViewer.lastVrm';
		// #endregion Three.js Setup

		// #region IndexedDB Helpers
		function openIdb() {
			return new Promise((resolve, reject) => {
				const req = indexedDB.open('vrmViewerDB', 1);
				req.onupgradeneeded = (e) => {
					const db = e.target.result;
					if (!db.objectStoreNames.contains('vrms')) db.createObjectStore('vrms');
				};
				req.onsuccess = (e) => resolve(e.target.result);
				req.onerror = (e) => reject(e.target.error);
			});
		}

		function saveVrmToIdb(file) {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readwrite');
				const store = tx.objectStore('vrms');
				const putReq = store.put(file, 'last');
				putReq.onsuccess = () => { tx.oncomplete = () => { db.close(); resolve(true); }; };
				putReq.onerror = (e) => { db.close(); reject(e); };
			}));

		}

		function getVrmFromIdb() {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readonly');
				const store = tx.objectStore('vrms');
				const getReq = store.get('last');
				getReq.onsuccess = () => { db.close(); resolve(getReq.result); };
				getReq.onerror = (e) => { db.close(); reject(e); };
			}));
		}

		function deleteVrmFromIdb() {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readwrite');
				const store = tx.objectStore('vrms');
				const delReq = store.delete('last');
				delReq.onsuccess = () => { db.close(); resolve(true); };
				delReq.onerror = (e) => { db.close(); reject(e); };
			}));

		}
		// #endregion IndexedDB Helpers

		// #region Last VRM Persistence
		/**
	 	* Save last VRM reference. For local files, store the blob in IndexedDB and save metadata in localStorage.
	 	 */
		function saveLastVrm(file, url, name) {
			try {
				if (file instanceof File || file instanceof Blob) {
					// Store blob in IndexedDB (no practical size limit beyond browser quota)
					saveVrmToIdb(file).then(() => {
						const entry = { type: 'idb', name: name || (file.name || 'recent.vrm') };
						localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
						statusDiv.textContent = 'Saved last VRM.';
					}).catch((e) => {
						console.warn('Failed to save VRM to IndexedDB:', e);
						// Fallback: save only metadata
						const entry = { type: 'meta', name: name || (file.name || 'recent.vrm') };
						localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
						statusDiv.textContent = 'Last VRM metadata saved (IDB failed).';
					});
				} else {
					// Not a File -> store URL reference
					const entry = { type: 'url', url, name: name || (url && url.split('/').pop()) };
					localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
					statusDiv.textContent = 'Saved last VRM (URL).';
				}
			} catch (e) {
				console.warn('saveLastVrm error:', e);
			}
		}

		/**
		 * Try loading the last VRM stored in localStorage.
		 * Returns true if a load was initiated, false otherwise.
		 */
		async function loadLastVrmFromStorage() {
			try {
				const raw = localStorage.getItem(LAST_VRM_KEY);
				if (!raw) return false;
				const entry = JSON.parse(raw);
				if (!entry) return false;
				if (entry.type === 'idb') {
					// Retrieve blob from IndexedDB
					const file = await getVrmFromIdb();
					if (!file) {
						statusDiv.textContent = 'No VRM found in IndexedDB.';
						return false;
					}
					const url = URL.createObjectURL(file);
					try {
						await loadVRM(url, entry.name || 'recent.vrm', file);
						URL.revokeObjectURL(url);
						return true;
					} catch (e) {
						URL.revokeObjectURL(url);
						throw e;
					}
				} else if (entry.type === 'url' && entry.url) {
					await loadVRM(entry.url, entry.name || (entry.url && entry.url.split('/').pop()));
					return true;
				} else if (entry.type === 'meta') {
					statusDiv.textContent = 'Last VRM was a local file and could not be restored automatically.';
					return false;
				}
			} catch (e) {
				console.warn('Could not load last VRM from storage:', e);
			}
			return false;
		}

		/** Replace currently displayed model with the default VRM file. */
		async function replaceWithDefaultVrm() {
			await loadVRM(VRM_MODEL_URL, 'default.vrm');
		}

		/** Clear the recent VRM entry from localStorage and update header. */
		function clearRecentVrm() {
			localStorage.removeItem(LAST_VRM_KEY);
			// Try to remove blob from IndexedDB as well
			deleteVrmFromIdb().catch(() => { /* ignore */ });
			vrmModelName.textContent = '';
			document.title = 'Figure - VRM Model Viewer';
			vrmAuthorName.textContent = '';
			statusDiv.textContent = 'Recent VRM removed.';
		}
		// #endregion Last VRM Persistence

		// #region Dispose & Cleanup
		/**
		 * Safely dispose a loaded VRM: geometries, materials, textures and stop mixers.
		 * @param {any} vrm VRM instance returned by the loader
		 */
		function disposeVrm(vrm) {
			if (!vrm) return;

			try {
				// Stop and clear mixer/actions associated with the previous VRM
				if (currentAction) {
					try { currentAction.stop(); } catch (e) { /* ignore */ }
					currentAction = undefined;
				}
				if (currentMixer) {
					try { currentMixer.stopAllAction(); } catch (e) { /* ignore */ }
					currentMixer = undefined;
				}

				// Traverse scene and dispose geometries/materials/textures
				if (vrm.scene) {
					vrm.scene.traverse((obj) => {
						if (obj.isMesh) {
							if (obj.geometry) {
								try { obj.geometry.dispose(); } catch (e) { /* ignore */ }
							}
							if (obj.material) {
								const disposeMaterial = (material) => {
									if (!material) return;
									if (material.map) {
										try { material.map.dispose(); } catch (e) { /* ignore */ }
									}
									if (material.dispose) {
										try { material.dispose(); } catch (e) { /* ignore */ }
									}
								};

								if (Array.isArray(obj.material)) {
									obj.material.forEach(disposeMaterial);
								} else {
									disposeMaterial(obj.material);
								}
							}
						}
					});
				}

				// If loader attached any extra resources on vrm, try to null them
				try { if (vrm.userData) vrm.userData = null; } catch (e) { }
			} catch (e) {
				console.warn('Error while disposing VRM:', e);
			}
		}
		// #endregion Dispose & Cleanup

		// #region Loader Plugins
		// --- GLTF Loader with VRM and VRMA Plugins ---
		const loader = new GLTFLoader();
		loader.crossOrigin = 'anonymous';

		loader.register((parser) => {
			return new VRMLoaderPlugin(parser);
		});

		loader.register((parser) => {
			return new VRMAnimationLoaderPlugin(parser);
		});
		// #endregion Loader Plugins

		// #region File Paths
		// --- File Paths ---
		const VRM_MODEL_URL = './VRM/default.vrm'; // Fixed VRM model path (relative path)
		// VRMA animations dictionary: map an id/key (used by buttons) to URL
		const VRMA_ANIMATIONS = {
			// 'Angry'       : './VRMA/tk256ailab/Angry.vrma',
			// 'Blush'       : './VRMA/tk256ailab/Blush.vrma',
			// 'Clapping'    : './VRMA/tk256ailab/Clapping.vrma',
			// 'Goodbye'     : './VRMA/tk256ailab/Goodbye.vrma',
			// 'Jump'        : './VRMA/tk256ailab/Jump.vrma',
			// 'LookAround'  : './VRMA/tk256ailab/LookAround.vrma',
			// 'Relax'       : './VRMA/tk256ailab/Relax.vrma',
			// 'Sad'         : './VRMA/tk256ailab/Sad.vrma',
			// 'Sleepy'      : './VRMA/tk256ailab/Sleepy.vrma',
			// 'Surprised'   : './VRMA/tk256ailab/Surprised.vrma',
			// 'Thinking'    : './VRMA/tk256ailab/Thinking.vrma',
			'Show Full Body' : './VRMA/VRoid Project/ShowFullBody.vrma',
			'Greeting'       : './VRMA/VRoid Project/Greeting.vrma',
			'Peace Sign'     : './VRMA/VRoid Project/PeaceSign.vrma',
			'Shoot'          : './VRMA/VRoid Project/Shoot.vrma',
			'Spin'           : './VRMA/VRoid Project/Spin.vrma',
			'Model Pose'     : './VRMA/VRoid Project/ModelPose.vrma',
			'Squat'          : './VRMA/VRoid Project/Squat.vrma',

			'Standard'       : './VRMA/VRoid Hub/Standard.vrma',
			'Innocent'       : './VRMA/VRoid Hub/Innocent.vrma',
			'Cool'           : './VRMA/VRoid Hub/Cool.vrma',
			'Ladylike'       : './VRMA/VRoid Hub/Ladylike.vrma',
			'Shy'            : './VRMA/VRoid Hub/Shy.vrma',
			'Energetic'      : './VRMA/VRoid Hub/Energetic.vrma',
			'Flamboyant'     : './VRMA/VRoid Hub/Flamboyant.vrma',
			'Gentleman'      : './VRMA/VRoid Hub/Gentleman.vrma',
			'Powerful'       : './VRMA/VRoid Hub/Powerful.vrma'
		};
		// #endregion File Paths

		// #region File Loading
		// --- File Loading Functions ---
		/**
		 * Loads a VRM model from a specified URL.
		 * @param {string} url The URL of the VRM file.
		 * @returns {Promise<any>} A promise that resolves with the loaded VRM.
		 */
		async function loadVRM(url, displayName, fileObject) {
			try {
				statusDiv.textContent = 'Loading VRM model...';

				return new Promise((resolve, reject) => {
					loader.load(
						url,
						(gltf) => {
							const vrm = gltf.userData.vrm;

							// Apply performance optimizations
							VRMUtils.removeUnnecessaryVertices(gltf.scene);
							VRMUtils.combineSkeletons(gltf.scene);
							VRMUtils.combineMorphs(vrm);

							// Disable frustum culling for all objects in the VRM scene
							vrm.scene.traverse((obj) => {
								obj.frustumCulled = false;
							});

							// Remove previous VRM if one is loaded
							if (currentVrm) {
								scene.remove(currentVrm.scene);
								// Safely dispose of geometries/materials/textures and stop mixers
								disposeVrm(currentVrm);
								currentVrm = undefined;
							}

							scene.add(vrm.scene);
							// Rotate model to face forward
							if (vrm.meta.metaVersion == '0') {
								vrm.scene.rotation.y = Math.PI; // VRM 0.x
							} else {
								vrm.scene.rotation._y = Math.PI; // VRM 1.x
							}
							currentVrm = vrm;

							// Create a new AnimationMixer for the current VRM
							currentMixer = new THREE.AnimationMixer(vrm.scene);

							// Update header with model name when provided
							if (displayName) {
								vrmModelName.textContent = currentVrm.meta.title || currentVrm.meta.name || displayName;
								document.title = vrmModelName.textContent + ' - Figure';
								vrmAuthorName.textContent = currentVrm.meta.author || 'Unknown author';
							}

							// Adjust ground shadow size and position to match model bounds
							try {
								if (groundShadow) {
									const box = new THREE.Box3().setFromObject(vrm.scene);
									const size = box.getSize(new THREE.Vector3());
									const maxDim = Math.max(size.x, size.z, 0.8);
									const scale = maxDim * 1.4; // slightly larger than footprint
									groundShadow.scale.set(scale, scale, 1);
									groundShadow.position.x = vrm.scene.position.x;
									groundShadow.position.z = vrm.scene.position.z;
								}
							} catch (e) { /* ignore bounding errors */ }

							statusDiv.textContent = 'VRM model loaded successfully!';
							console.log('VRM loaded:', vrm);

							updateButtons();

							// Populate blend shape controls for the loaded VRM
							try { populateBlendShapeControls(); } catch (e) { console.warn('populateBlendShapeControls failed:', e); }

							// Populate materials list
							try { populateMaterials(); } catch (e) { console.warn('populateMaterials failed:', e); }

							// Populate model info
							try { populateModelInfo(); } catch (e) { console.warn('populateModelInfo failed:', e); }

							// Save last VRM reference to localStorage (attempt to persist)
							try { saveLastVrm(fileObject, url, displayName || (url && url.split('/').pop())); } catch (e) { console.warn(e); }

							resolve(vrm);
						},
						(progress) => {
							const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
							statusDiv.textContent = `Loading VRM model... ${percent}%`;
						},
						(error) => {
							console.error('Error loading VRM:', error);
							statusDiv.textContent = 'An error occurred while loading the VRM model';
							reject(error);
						}
					);
				});
			} catch (error) {
				console.error('Error in loadVRM:', error);
				statusDiv.textContent = 'An error occurred while loading the VRM model';
			}
		}

		/**
		 * Loads a VRMA animation from a specified URL and converts it to a THREE.AnimationClip.
		 * @param {string} url The URL of the VRMA file.
		 * @returns {Promise<THREE.AnimationClip>} A promise that resolves with the generated AnimationClip.
		 */
		async function loadVRMA(url, displayName) {
			if (!currentVrm) {
				statusDiv.textContent = 'VRM model not loaded. Please load the VRM model first.';
				return;
			}

			try {
				statusDiv.textContent = 'Loading VRMA animation...';

				return new Promise((resolve, reject) => {
					loader.load(
						url,
						(gltf) => {
							console.log('GLTF loaded (VRMA):', gltf);

							// gltf.userData.vrmAnimations[0] contains the raw VRMAnimation data object
							const vrmAnimationData = gltf.userData.vrmAnimations && gltf.userData.vrmAnimations[0];

							if (vrmAnimationData) {
								// Call the standalone createVRMAnimationClip function
								// It takes the VRMAnimation data object and the current VRM model
								const clip = createVRMAnimationClip(vrmAnimationData, currentVrm);

								if (clip) {
									vrmaAnimationClip = clip;

									statusDiv.textContent = 'Animation loaded successfully!';
									console.log('Generated AnimationClip:', vrmaAnimationClip);

									updateButtons(); // Enable play/pause/stop after animation is loaded

									// Auto-play the animation when loaded
									try {
										playAnimation();
									} catch (e) {
										console.warn('Auto-play failed:', e);
									}

									resolve(vrmaAnimationClip);
								} else {
									throw new Error('Failed to create AnimationClip from VRMA data.');
								}
							} else {
								throw new Error('No valid VRMA animation found in the file.');
							}
						},
						(progress) => {
							const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
							statusDiv.textContent = `Loading VRMA animation... ${percent}%`;
						},
						(error) => {
							console.error('Error loading animation:', error);
							statusDiv.textContent = 'An error occurred while loading the animation file: ' + error.message;
							reject(error);
						}
					);
				});
			} catch (error) {
				console.error('Error in loadVRMA:', error);
				statusDiv.textContent = 'An error occurred while loading the animation file';
			}
		}
		// #endregion File Loading

		// #region Animation Controls
		// --- Animation Control Functions ---
		/**
		 * Starts playing the loaded VRMA animation.
		 */
		function playAnimation() {
			if (currentVrm && vrmaAnimationClip && currentMixer) {
				// Stop any currently playing action
				if (currentAction) {
					currentAction.stop();
				}

				try {
					console.log('Playing animation...');

					// Create and configure animation action from the generated clip
					currentAction = currentMixer.clipAction(vrmaAnimationClip);
					currentAction.setLoop(THREE.LoopRepeat); // Loop the animation
					currentAction.clampWhenFinished = true; // Stay at the last frame when finished
					currentAction.reset(); // Reset to the start of the animation
					currentAction.play(); // Start playing

					statusDiv.textContent = `Playing animation (${vrmaAnimationClip.tracks.length} tracks, ${vrmaAnimationClip.duration.toFixed(2)}s)`;
					// update toggle icon if present
					setPlayPauseIcon(true);
					console.log('Animation started successfully.');
				} catch (error) {
					console.error('Error playing animation:', error);
					statusDiv.textContent = 'An error occurred while playing the animation: ' + error.message;
				}
			} else {
				statusDiv.textContent = 'A VRM model and animation must be loaded.';
			}
		}

		/**
		 * Toggles the pause state of the animation.
		 */
		function pauseAnimation() {
			if (currentAction) {
				currentAction.paused = !currentAction.paused;
				statusDiv.textContent = currentAction.paused ? 'Animation paused' : 'Animation playing...';
				setPlayPauseIcon(!currentAction.paused);
			}
		}

		/**
		 * Stops the animation and resets the model's pose.
		 */
		function stopAnimation() {
			if (currentAction) {
				currentAction.stop();
				currentAction = undefined;
				currentMixer.stopAllAction(); // Stop all actions on the mixer

				// Reset VRM pose (optional, but good for stopping)
				if (currentVrm) {
					currentVrm.humanoid.resetPose();
				}
				// reset play/pause icon to play
				setPlayPauseIcon(false);

				statusDiv.textContent = 'Animation stopped.';
			}
		}
		// #endregion Animation Controls

		// #region UI & Events
		// --- UI and Event Handlers ---
		/**
		 * Updates the state of the control buttons based on loaded files.
		 */
		function updateButtons() {
			const hasVrm = currentVrm !== undefined;
			const hasVrma = vrmaAnimationClip !== undefined;

			// Enable VRMA selection buttons once VRM is loaded
			const vrmaBtns = document.querySelectorAll('.vrma-btn');
			vrmaBtns.forEach(btn => { btn.disabled = !hasVrm; });

			// Enable play/pause and stop buttons only if both VRM and an animation are loaded
			if (playPauseBtn) playPauseBtn.disabled = !(hasVrm && hasVrma);
			stopBtn.disabled = !(hasVrm && hasVrma);
		}

		// Add event listeners for VRMA animation buttons (lookup by key instead of array index)
		function normalizeKey(s) { return String(s || '').toLowerCase().replace(/[^a-z0-9]/g, ''); }
		const animationKeys = Object.keys(VRMA_ANIMATIONS || {});
		const normalizedMap = {};
		animationKeys.forEach(k => { normalizedMap[normalizeKey(k)] = VRMA_ANIMATIONS[k]; });

		// Populate VRMA buttons dynamically from the VRMA_ANIMATIONS dictionary
		function populateVrmaButtons() {
			const container = document.querySelector('#vrmaButtons .item-group-content');
			if (!container) return;
			container.innerHTML = '';
			const keys = Object.keys(VRMA_ANIMATIONS || {});
			keys.forEach(k => {
				const url = VRMA_ANIMATIONS[k];
				const clean = String(url).replace(/^\.\/+/, '');
				const parts = clean.split('/');
				const folder = parts.length >= 2 ? parts[1] : '';

				const btn = document.createElement('button');
				btn.className = 'item vrma-btn';
				btn.disabled = true; // will be enabled by updateButtons when VRM loaded
				btn.dataset.key = k;
				btn.setAttribute('translate', 'no');

				const inner = document.createElement('div');
				inner.style.width = '90%';
				const strong = document.createElement('strong');
				strong.textContent = k + ' ';
				const span = document.createElement('span');
				span.textContent = folder ? ('by ' + folder) : '';
				inner.appendChild(strong);
				inner.appendChild(span);
				btn.appendChild(inner);

				btn.addEventListener('click', async () => {
					if (currentAction) { try { currentAction.stop(); } catch (e) { } currentAction = undefined; }
					vrmaAnimationClip = undefined;
					const key = btn.dataset.key || btn.textContent.trim();
					const n = normalizeKey(key);
					let url2 = normalizedMap[n];
					if (!url2) {
						for (const kk of keys) {
							if (normalizeKey(kk) === n) { url2 = VRMA_ANIMATIONS[kk]; break; }
						}
					}
					if (!url2) {
						statusDiv.textContent = 'Animation not found for ' + key;
						console.warn('No VRMA mapping for button key:', key);
						return;
					}
					await loadVRMA(url2, url2.split('/').pop());
					if (isMobile()) document.getElementById('controls-bar').classList.remove('show');
				});

				container.appendChild(btn);
			});
		}

		// Build the buttons now
		populateVrmaButtons();

		// Toggle play/pause button handler
		function setPlayPauseIcon(isPlaying) {
			if (!playPauseBtn) return;
			playPauseBtn.textContent = isPlaying ? 'pause' : 'play_arrow';
		}

		function togglePlayPause() {
			if (!currentVrm || !vrmaAnimationClip) {
				statusDiv.textContent = 'A VRM model and animation must be loaded.';
				return;
			}
			// If no action, start playing
			if (!currentAction) {
				playAnimation();
				setPlayPauseIcon(true);
				return;
			}
			// Toggle paused state
			currentAction.paused = !currentAction.paused;
			setPlayPauseIcon(!currentAction.paused);
			statusDiv.textContent = currentAction.paused ? 'Animation paused' : 'Animation playing...';
		}

		if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);
		stopBtn.addEventListener('click', stopAnimation);

		// Reset camera button
		const resetCameraBtn = document.getElementById('resetCameraBtn');
		let resetCameraAnimId = null;
		// Ease in-out quad
		function easeInOutQuad(t) {
			return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
		}
		function smoothResetCamera(duration = 600) {
			if (resetCameraAnimId) cancelAnimationFrame(resetCameraAnimId);
			const startPos = camera.position.clone();
			const startTarget = controls.target.clone();
			const endPos = DEFAULT_CAMERA_POSITION.clone();
			const endTarget = DEFAULT_CONTROLS_TARGET.clone();
			const startTime = performance.now();

			function step(now) {
				const elapsed = now - startTime;
				let t = Math.min(1, elapsed / duration);
				const e = easeInOutQuad(t);
				camera.position.lerpVectors(startPos, endPos, e);
				controls.target.lerpVectors(startTarget, endTarget, e);
				controls.update();
				if (t < 1) {
					resetCameraAnimId = requestAnimationFrame(step);
				} else {
					resetCameraAnimId = null;
				}
			}

			resetCameraAnimId = requestAnimationFrame(step);
		}

		if (resetCameraBtn) resetCameraBtn.addEventListener('click', () => smoothResetCamera(600));

		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});

		// --- Drag-and-Drop File Support ---
		// Allow users to drop a .vrm or .vrma file onto the preview area (`mainWrapper`).
		async function handleFileDrop(file) {
			if (!file) return;
			const name = file.name || '';
			const lname = name.toLowerCase();

			if (lname.endsWith('.vrm')) {
				const url = URL.createObjectURL(file);
				try {
					await loadVRM(url, file.name, file);
				} catch (e) {
					console.error('Failed to load dropped VRM:', e);
				} finally {
					URL.revokeObjectURL(url);
				}
			} else if (lname.endsWith('.vrma')) {
				const url = URL.createObjectURL(file);
				try {
					await loadVRMA(url, file.name);
				} catch (e) {
					console.error('Failed to load dropped VRMA:', e);
				} finally {
					URL.revokeObjectURL(url);
				}
			} else {
				statusDiv.textContent = 'Arquivo não suportado. Solte um .vrm ou .vrma.';
			}
		}

		mainWrapper.addEventListener('dragover', (e) => {
			e.preventDefault();
			e.dataTransfer.dropEffect = 'copy';
		});

		mainWrapper.addEventListener('drop', async (e) => {
			e.preventDefault();
			const dt = e.dataTransfer;
			if (!dt) return;
			const file = dt.files && dt.files[0];
			await handleFileDrop(file);
		});

		document.body.addEventListener('keydown', async (e) => {
			if (e.key == 'r') {
				smoothResetCamera(600);
			}
			if (e.key == 'p') {
				togglePlayPause();
				if (currentAction && currentAction.paused) {
					showToast('Animation paused', 'pause');
				} else {
					showToast('Animation playing', 'play_arrow');
				}
			}
			if (e.key == 'F1') {
				showMessageFromFile('dialog/about.html');
				closeAllDialogs();
				hideAllMenus();
			}
		});

		// --- Helpers ---
		// const gridHelper = new THREE.GridHelper(10, 10);
		// scene.add(gridHelper);

		// const axesHelper = new THREE.AxesHelper(5);
		// scene.add(axesHelper);

		/**
		 * Create a circular ground shadow using a canvas radial gradient texture.
		 * @param {number} size Base diameter in world units
		 */
		function createGroundShadow(size = 1) {
			const sizePx = 1024;
			const canvas = document.createElement('canvas');
			canvas.width = sizePx;
			canvas.height = sizePx;
			const ctx = canvas.getContext('2d');
			// radial gradient from center (opaque) to transparent at edge
			const cx = sizePx / 2, cy = sizePx / 2, r = sizePx / 2;
			const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
			g.addColorStop(0, '#00000033');
			g.addColorStop(1, '#00000000');
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, sizePx, sizePx);

			const tex = new THREE.CanvasTexture(canvas);
			tex.encoding = THREE.sRGBEncoding;
			tex.needsUpdate = true;

			const geom = new THREE.PlaneGeometry(0.5, 0.5);
			const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
			const mesh = new THREE.Mesh(geom, mat);
			mesh.rotation.x = -Math.PI / 2; // lie flat on XZ plane
			mesh.renderOrder = 999;
			mesh.receiveShadow = false;
			mesh.position.y = 0.001; // slightly above ground to avoid z-fighting
			mesh.scale.set(size, size, 1);
			scene.add(mesh);
			return mesh;
		}

		// instantiate the ground shadow
		groundShadow = createGroundShadow(1);

		/**
		 * Make all `.item-group-header` clickable to toggle their sibling
		 * `.item-group-content` between `expanded` and `collapsed`.
		 */
		function attachItemGroupToggles() {
			const headers = document.querySelectorAll('.item-group-header');
			headers.forEach(h => {
				const group = h.closest('.item-group');
				if (!group) return;
				const content = group.querySelector('.item-group-content');
				if (!content) return;
				// Ensure keyboard accessibility
				h.setAttribute('role', 'button');
				h.tabIndex = 0;
				h.addEventListener('click', () => {
					content.classList.toggle('expanded');
					content.classList.toggle('collapsed');
				});
				h.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' || e.key === ' ') {
						e.preventDefault();
						h.click();
					}
				});
			});
		}

		// #endregion UI & Events

		// #region Blend Shape Controls
		const BLENDSHAPE_ORDER = [
			// neutral
			'neutral',

			// vocals (phonetical japanese)
			'a', 'i', 'u', 'e', 'o',

			// eyes
			'blink', 'blink_r', 'blink_l',

			// universal vrm expressions
			'angry', 'fun', 'joy', 'sorrow',
		];

		/**
		 * Normalize blendshape names to a canonical form
		 * to guarantee stable matching across VRM / VRoid variations.
		 */
		function normalizeBlendShapeName(name) {
			return name
				.toLowerCase()
				.trim()
				.replace(/\s+/g, '')
				.replace(/-/g, '_')
				.replace(/_?left$/, '_l')
				.replace(/_?right$/, '_r');
		}

		/**
		 * Apply a blend shape value (0-100) to the current VRM.
		 */
		function applyBlendShape(key, value100) {
			if (!currentVrm) return;
			const v = Math.max(0, Math.min(100, Number(value100))) / 100.0;
			currentVrm.expressionManager.setValue(key, v);
		}

		/**
		 * Sort blendshape names:
		 * 1. Fixed VRM order
		 * 2. Custom expressions (alphabetical)
		 */
		function sortBlendShapeNames(names) {
			const nameMap = new Map();

			// index detected names using normalized keys
			names.forEach(name => {
				nameMap.set(normalizeBlendShapeName(name), name);
			});

			const result = [];

			// push fixed expressions strictly in canonical order
			BLENDSHAPE_ORDER.forEach(key => {
				if (nameMap.has(key)) {
					result.push(nameMap.get(key));
					nameMap.delete(key);
				}
			});

			// remaining expressions are custom → alphabetical
			const custom = Array.from(nameMap.values()).sort((a, b) =>
				a.localeCompare(b)
			);

			return result.concat(custom);
		}

		/**
		 * Build and attach blend shape range controls into the blendShapeRanges content area.
		 */
		function populateBlendShapeControls() {
			const container = document.querySelector('#blendShapeRanges .item-group-content');
			if (!container) return;
			container.innerHTML = '';

			if (!currentVrm) return;

			// collect morph target names from meshes
			const names = new Set();
			currentVrm.scene.traverse(obj => {
				if (!obj.isMesh || !obj.morphTargetDictionary) return;
				Object.keys(obj.morphTargetDictionary).forEach(n => names.add(n));
			});

			// collect blendshape proxy names (best effort)
			try {
				if (currentVrm.blendShapeProxy) {
					if (Array.isArray(currentVrm.blendShapeProxy.expressions)) {
						currentVrm.blendShapeProxy.expressions.forEach(e => {
							if (e?.name) names.add(e.name);
						});
					}
					if (currentVrm.blendShapeProxy._binds) {
						Object.keys(currentVrm.blendShapeProxy._binds).forEach(k => names.add(k));
					}
				}
			} catch (_) {}

			// build UI controls in correct order
			sortBlendShapeNames(Array.from(names)).forEach(name => {
				const label = document.createElement('span');
				label.textContent = name;
				label.style.marginRight = '6px';

				const input = document.createElement('input');
				input.className = 'item';
				input.type = 'range';
				input.min = 0;
				input.max = 100;
				input.value = 0;
				input.style.marginRight = '12px';

				input.id = 'blend_' + name.replace(/[^a-z0-9]/gi, '_');

				input.addEventListener('input', e =>
					applyBlendShape(name, e.target.value)
				);

				// initialize slider value
				let initVal = 0;
				try {
					if (currentVrm.blendShapeProxy?.getValue) {
						initVal = Math.round(
							currentVrm.blendShapeProxy.getValue(name) * 100
						);
					} else {
						currentVrm.scene.traverse(obj => {
							if (!obj.isMesh || !obj.morphTargetDictionary || !obj.morphTargetInfluences) return;
							const idx = obj.morphTargetDictionary[name];
							if (idx !== undefined) {
								initVal = Math.round(
									(obj.morphTargetInfluences[idx] || 0) * 100
								);
							}
						});
					}
				} catch (_) {}

				input.value = initVal;

				container.appendChild(label);
				container.appendChild(input);
			});
		}
		// #endregion Blend Shape Controls

		// #region Materials & Model Info
		/**
		 * Populate the Materials panel with materials used by the current VRM.
		 * Shows a thumbnail (if texture present), download button and a visibility checkbox.
		 */
		function populateMaterials() {
			const container = document.querySelector('#materialsList .item-group-content');
			if (!container) return;
			container.innerHTML = '';

			if (!currentVrm) {
				container.textContent = 'Load a VRM to list materials.';
				return;
			}

			// Collect unique materials
			const materials = new Map();
			currentVrm.scene.traverse((obj) => {
				if (!obj.isMesh) return;
				const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
				mats.forEach(m => { if (!m) return; if (!materials.has(m.uuid)) materials.set(m.uuid, m); });
			});

			if (materials.size === 0) {
				container.textContent = 'No materials found in model.';
				return;
			}

			materials.forEach((mat) => {
				const entry = document.createElement('div');
				entry.className = 'material-entry';
				entry.style.display = 'flex';
				entry.style.alignItems = 'center';
				entry.style.gap = '8px';
				entry.style.marginBottom = '8px';

				// thumbnail
				const thumb = document.createElement('img');
				thumb.style.width = '64px';
				thumb.style.height = '64px';
				thumb.style.borderRadius = '4px';
				thumb.style.objectFit = 'cover';
				thumb.alt = 'no texture';
				entry.appendChild(thumb);

				const div = document.createElement('div');
				entry.appendChild(div);

				const title = document.createElement('div');
				title.style.fontSize = '0.9em';
				title.style.display = 'block';
				title.style.boxSizing = 'border-box';
				title.style.marginRight = '12px';
				title.textContent = mat.name || mat.uuid;
				title.title = mat.name || mat.uuid;
				div.appendChild(title);

				const mainMap = mat.map || mat.baseMap || null;
				if (mainMap && mainMap.image) {
					try {
						const img = mainMap.image;
						const canvas = document.createElement('canvas');
						canvas.width = 128; canvas.height = 128;
						const ctx = canvas.getContext('2d');
						ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
						thumb.src = canvas.toDataURL('image/png');
					} catch (e) {
						thumb.alt = 'preview unavailable';
					}
				} else {
					thumb.alt = 'no texture';
				}

				// download button (lazy generate data URL)
				const dl = document.createElement('button');
				dl.textContent = 'Download';
				dl.disabled = !(mainMap && mainMap.image);
				dl.addEventListener('click', () => {
					if (!(mainMap && mainMap.image)) return;
					try {
						const img = mainMap.image;
						const canvas = document.createElement('canvas');
						canvas.width = img.width || 1024;
						canvas.height = img.height || 1024;
						const ctx = canvas.getContext('2d');
						ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
						const url = canvas.toDataURL('image/png');
						const a = document.createElement('a');
						a.href = url;
						a.download = (mat.name || mat.uuid) + '.png';
						a.click();
					} catch (e) {
						console.warn('Failed to export texture:', e);
					}
				});
				div.appendChild(dl);

				// visibility checkbox
				const visLabel = document.createElement('label');
				visLabel.style.display = 'flex';
				visLabel.style.alignItems = 'center';
				const checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				checkbox.checked = (mat.opacity === undefined) ? true : mat.opacity > 0;
				checkbox.style.marginRight = '6px';
				checkbox.addEventListener('change', () => {
					if (!checkbox.checked) {
						if (mat.userData.__origOpacity === undefined) mat.userData.__origOpacity = (mat.opacity === undefined) ? 1.0 : mat.opacity;
						mat.opacity = 0;
						mat.transparent = true;
					} else {
						mat.opacity = (mat.userData.__origOpacity !== undefined) ? mat.userData.__origOpacity : 1.0;
						mat.transparent = mat.opacity < 1.0;
					}
					// ensure renderer updates (materials changed)
				});
				visLabel.appendChild(checkbox);
				const visText = document.createElement('span'); visText.textContent = 'Visible';
				visLabel.appendChild(visText);
				div.appendChild(visLabel);

				container.appendChild(entry);
			});
		}

		function populateModelInfo() {
			const container = document.querySelector('#modelInfo .item-group-content');
			if (!container) return;
			container.innerHTML = '';

			if (!currentVrm) {
				container.textContent = 'Load a VRM to see model information.';
				return;
			}

			const meta = currentVrm.meta;
			const infoTable = document.createElement('table');
			const addItem = (label, value) => {
					const tr = document.createElement('tr');
					const tdLabel = document.createElement('td');
					tdLabel.style.fontWeight = 'bold';
					tdLabel.style.borderBottom = '1px solid var(--border-light-color)'
					tdLabel.textContent = label;
					const tdValue = document.createElement('td');
					tdValue.style.borderBottom = '1px solid var(--border-light-color)'
					tdValue.textContent = value;
					tr.appendChild(tdLabel);
					tr.appendChild(tdValue);
					infoTable.appendChild(tr);
				};

			if (meta.metaVersion == '0') {
				// VRM 0.x

				// avatar information
				addItem('Title', meta.title || 'N/A');
				addItem('Creator', meta.author || 'N/A');
				addItem('Contact Information', meta.contactInformation || 'N/A');
				addItem('Reference', meta.reference || 'N/A');
				addItem('Version', meta.version || 'N/A');
				addItem('VRM version', meta.metaVersion || 'N/A');
				
				// avatar personality
				addItem('Allowed User Name', meta.allowedUserName || 'N/A');
				addItem('Depictions of violence', meta.violentUssageName || 'No');
				addItem('Depictions of sexual acts', meta.sexualUssageName || 'No');
				addItem('Commercial use', meta.commercialUssageName || 'No');
				addItem('Permission information URL', meta.otherPermissionUrl || 'N/A');

				// redistribution and alteration
				addItem('License', meta.licenseName || 'N/A');

				container.appendChild(infoTable);
			} else {
				// VRM 1.x

				// avatar information
				addItem('Avatar name', meta.name || 'N/A');
				addItem('Version', meta.version || 'N/A');
				addItem('Authors', (meta.authors && meta.authors.length > 0) ? meta.authors.join(', ') : 'N/A');
				addItem('Creator copyright', meta.copyrightInformation || 'N/A');
				addItem('Contact Information', meta.contactInformation || 'N/A');
				addItem('References', (meta.references && meta.references.length > 0) ? meta.references.join(', ') : 'N/A');
				addItem('Third party licenses', meta.thirdPartyLicenses || 'N/A');

				// avatar permission settings
				addItem('Avatar use permission', meta.avatarPermission || 'N/A');
				addItem('Violent usage', meta.allowExcessivelyViolentUsage ? 'Yes' : 'No');
				addItem('Sexual usage', meta.allowExcessivelySexualUsage ? 'Yes' : 'No');
				addItem('Political usage', meta.allowPoliticalOrReligiousUsage ? 'Yes' : 'No');
				addItem('Antisocial usage', meta.allowAntisocialOrHateUsage ? 'Yes' : 'No');
				addItem('Commercial usage', meta.commercialUsage || 'No');

				// redistribution and alteration
				addItem('Redistribution', meta.allowRedistribution ? 'Yes' : 'No');
				addItem('Alterations', meta.modification || 'N/A');
				addItem('Attribution', meta.creditNotation || 'N/A');
			}

			container.appendChild(infoTable);
		}

		// #endregion Materials & Model Info

		// #region Animation Loop
		// --- Animation Loop ---
		const clock = new THREE.Clock();

		function animate() {
			requestAnimationFrame(animate);

			const deltaTime = clock.getDelta();

			// Update VRM and AnimationMixer
			if (currentVrm) {
				currentVrm.update(deltaTime);
			}
			if (currentMixer) {
				currentMixer.update(deltaTime);
			}

			// Keep shadow centered under the current VRM on the ground
			if (groundShadow && currentVrm && currentVrm.scene) {
				groundShadow.position.x = currentVrm.scene.position.x;
				groundShadow.position.z = currentVrm.scene.position.z;
			}

			controls.update(); // Update orbit controls
			renderer.render(scene, camera);
		}

		// Start the animation loop
		animate();
		// #endregion Animation Loop

		// #region Initial Load
		// --- Initial Load ---
		// Load the fixed VRM model when the page loads
		window.addEventListener('DOMContentLoaded', async () => {
			// Try to restore a previously loaded VRM from localStorage.
			const restored = await loadLastVrmFromStorage();
			if (!restored) {
				await loadVRM(VRM_MODEL_URL, 'default.vrm');
			}
			await loadVRMA(VRMA_ANIMATIONS['Standard'], 'Standard.vrma');
			updateButtons(); // Update button states after VRM is loaded
			if (!isMobile()) document.getElementById('controls-bar').classList.add('show');
		});
		// #endregion Initial Load
	</script>
</body>

</html>