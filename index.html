<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Figure — VRM & VRMA Model Viewer for Web</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

	<!-- seo -->
	<meta name="description" content="Figure is a fast, lightweight web-based VRM and VRMA model viewer. Preview and inspect VRM characters directly in your browser."/>
	<meta name="keywords" content="VRM viewer, VRMA viewer, VRM model viewer, VRoid model viewer, VRM web viewer, VRoid, VRoid Studio, VRoid Hub, VRM 1.0, VRM 0.0, 3D avatar viewer, VTuber tools" />
	<meta name="author" content="Figure" />
	<meta name="robots" content="index, follow" />
	<meta name="language" content="en" />
	<meta property="og:type" content="website" />
	<meta property="og:title" content="Figure — VRM & VRMA Model Viewer" />
	<meta property="og:description" content="Preview VRM and VRMA models directly in your browser." />
	<meta property="og:image" content="static/og-image.png" />
	<meta property="og:url" content="https://flarom.github.io/figure" />
	<meta property="og:site_name" content="Figure" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:title" content="Figure — VRM & VRMA Model Viewer" />
	<meta name="twitter:description" content="Preview VRM and VRMA models directly in your browser."/>
	<meta name="twitter:image" content="static/og-image.png" />

	<link rel="stylesheet" href="style/palette.css">
	<link rel="stylesheet" href="style/share.css">
	<link rel="stylesheet" href="style/prompts.css">
	<link rel="shortcut icon" href="static/favicon.svg" type="image/x-icon">
</head>

<body class="theme-light">
	<div id="controls-bar" class="sidebar">
		<header class="window-title">
			<div class="header-left">
				<button id="openFileBtn" class="icon-button hide-on-mobile" translate="no" title="Open model">open_in_browser</button>
				<button class="icon-button hide-on-pc" onmousedown="toggleSidebar('controls-bar')">arrow_back</button>
			</div>
			<div class="header-center">
				<div id="vrm-model-name">Figure</div>
				<span id="vrm-author-name"></span>
			</div>
			<div class="header-right">
				<div class="dropdown">
					<button class="icon-button" translate="no" onmousedown="toggleDropdown('more-menu')">more_vert</button>
					<div class="dropdown-content menu" id="more-menu">
						<button class="text-button" id="openFileBtn2">
							<span>Open model</span>
						</button>
						<button class="text-button" id="modelInfoBtn">
							<span>Model information</span>
						</button>
						<hr>
						<button class="text-button" onmouseup="showMessageFromFile('dialog/settings.html', true, false, true, true, 600); hideAllMenus()">
							<span>Settings</span>
							<kbd>Ctrl+,</kbd>
						</button>
						<hr>
						<button class="text-button" onmouseup="showMessageFromFile('dialog/about.html'); hideAllMenus()">
							<span>About Figure</span>
							<kbd>F1</kbd>
						</button>
					</div>
				</div>
			</div>
		</header>
		<div class="tab" id="tab-model">
			<details open><summary>Body</summary>
				<div class="setting top switch-wrapper">
					<span class="switch-text">Animation</span>
					<select name="animationSlct" id="AnimationSlct"></select>
				</div>
				<div class="setting bottom switch-wrapper">
					<span class="switch-text">Pose</span>
					<select name="poseSlct" id="PoseSlct"></select>
				</div>
				<div class="setting bottom top switch-wrapper">
					<span class="switch-text">Reset pose</span>
					<button class='text-button' id="stopBtn" disabled>Reset</button>
				</div>
			</details>
			<details open><summary>Face</summary>
				<div class="setting top switch-wrapper">
					<span class="switch-text">Look at camera</span>
					<label class="switch">
						<input type="checkbox" id="look_follow_camera" />
						<span class="slider"></span>
					</label>
				</div>
				<div class="setting bottom">
					<div id="look_joystick" class="joystick-container" style="touch-action:none;">
						<div id="look_joystick_handle" class="joystick-handle"></div>
					</div>
					<div style="font-size:0.85em;opacity: 0.5;">Drag inside the box to aim eyes.</div>
				</div>
				<div class="setting top bottom switch-wrapper">
					<span class="switch-text">Recenter eyes</span>
					<button class='text-button' id="resetLookBtn">Recenter</button>
				</div>
				<div id="blendShapeRanges">

				</div>
				<div class="setting top bottom switch-wrapper">
					<span class="switch-text">Clear all expressions</span>
					<button class='text-button' id="resetExpressionBtn">Reset</button>
				</div>
			</details>
			<details open><summary>Materials</summary>
				<div id="materialsList">
					
				</div>
			</details>
		</div>
		<div class="tab" id="tab-scene">

		</div>
		<div class="tab-control">
			<button class="tab-button" id="tab-btn-tab-model">
				<span class="tab-icon">accessibility</span>
				<span class="tab-label">Model</span>
			</button>
			<button class="tab-button" id="tab-btn-tab-scene">
				<span class="tab-icon">landscape</span>
				<span class="tab-label">Scene</span>
			</button>
		</div>
	</div>

	<div class="status-bar show" id="status">
		<div class="status-bar-left">
			<span id="status">Loading VRM model...</span>
		</div>
		<div class="status-bar-right"></div>
	</div>

	<div class="main-wrapper" id="mainWrapper" onclick="hideAllMenus();">
		<header class="window-title">
		<div class="header-left">
			<button class="icon-button" translate="no" onmousedown="toggleSidebar('controls-bar')"
				title="Toggle sidebar">side_navigation</button>
		</div>
		<div class="header-center">
			
		</div>
		<div class="header-right">
			<button class="icon-button" translate="no" id="playPauseBtn" title="Play / Pause animation (P)" disabled>play_arrow</button>
			<button class="icon-button" translate="no" id="resetCameraBtn" title="Recenter (R)">reset_focus</button>
		</div>
	</header>
	</div>

	<!-- hidden file input for Open model button -->
	<input type="file" id="fileInput" accept=".vrm,.vrma" style="display:none" />

	<script src="script/settings.js"></script>
	<script src="script/prompts.js"></script>
	<script src="script/i18n.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
					"@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
					"@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3/lib/three-vrm-animation.module.min.js"
				}
			}
		</script>

	<script type="module">
		import * as THREE from 'three';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
		import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

		// #region DOM Elements
		// DOM elements
		const vrmaButtonsContainer = document.querySelector('#vrmaButtons .item-group-content');
		const playPauseBtn = document.getElementById('playPauseBtn');
		const stopBtn = document.getElementById('stopBtn');
		const statusDiv = document.getElementById('status');
		const mainWrapper = document.getElementById('mainWrapper');
		const vrmModelName = document.getElementById('vrm-model-name');
		const vrmAuthorName = document.getElementById('vrm-author-name');
		const openFileBtn = document.getElementById('openFileBtn');
		const openFileBtn2 = document.getElementById('openFileBtn2');
		const fileInput = document.getElementById('fileInput');
		const modelInfoBtn = document.getElementById('modelInfoBtn');
		const animationSelect = document.getElementById('AnimationSlct');
		const poseSelect = document.getElementById('PoseSlct');

		// #endregion DOM Elements

		// Wire Open model button to hidden file input
		if (openFileBtn && fileInput) {
			openFileBtn.addEventListener('click', (e) => {
				e.preventDefault();
				fileInput.click();
			});
			fileInput.addEventListener('change', async (ev) => {
				const f = ev.target.files && ev.target.files[0];
				if (f) await handleFileDrop(f);
				fileInput.value = ''; // reset
			});
		}
		if (openFileBtn2 && fileInput) {
			openFileBtn2.addEventListener('click', (e) => {
				e.preventDefault();
				fileInput.click();
			});
			fileInput.addEventListener('change', async (ev) => {
				const f = ev.target.files && ev.target.files[0];
				if (f) await handleFileDrop(f);
				fileInput.value = ''; // reset
			});
		}

		// #region Three.js Setup
		// --- Three.js Setup ---
		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
		mainWrapper.appendChild(renderer.domElement);

		const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
		camera.position.set(0.0, 0.75, 4.0);
		const DEFAULT_CAMERA_POSITION = new THREE.Vector3(0.0, 0.75, 4.0);
		const DEFAULT_CONTROLS_TARGET = new THREE.Vector3(0.0, 1.0, 0.0);

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.screenSpacePanning = true;
		controls.target.copy(DEFAULT_CONTROLS_TARGET);
		controls.update();

		const scene = new THREE.Scene();
		// Use CSS variable `--background-color` for the scene background.
		// Read from `body` (theme class) first, then fall back to `:root`, then a hard fallback.
		const bodyBg = getComputedStyle(document.body).getPropertyValue('--background-color-2').trim();
		const rootBg = getComputedStyle(document.documentElement).getPropertyValue('--background-color-2').trim();
		const cssBg = bodyBg || rootBg || '#222222';
		scene.background = new THREE.Color(cssBg);
		
		// Expose scene to non-module scripts for compatibility / debugging.
		window.scene = scene;

		const light = new THREE.DirectionalLight(0xffffff, 3.0); // Increased intensity
		light.position.set(0.5, 1.0, 1.0).normalize();
		scene.add(light);

		const ambientLight = new THREE.AmbientLight(0xffffff, 0); // ambient light
		scene.add(ambientLight);

		// --- Global Variables for VRM and Animation ---
		let currentVrm = undefined;
		let currentMixer = undefined;
		let currentAction = undefined;
		let vrmaAnimationClip = undefined; // Store the final THREE.AnimationClip
		let groundShadow = null;

		const LAST_VRM_KEY = 'vrmViewer.lastVrm';
		// #endregion Three.js Setup

		// #region IndexedDB Helpers
		function openIdb() {
			return new Promise((resolve, reject) => {
				const req = indexedDB.open('vrmViewerDB', 1);
				req.onupgradeneeded = (e) => {
					const db = e.target.result;
					if (!db.objectStoreNames.contains('vrms')) db.createObjectStore('vrms');
				};
				req.onsuccess = (e) => resolve(e.target.result);
				req.onerror = (e) => reject(e.target.error);
			});
		}

		function saveVrmToIdb(file) {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readwrite');
				const store = tx.objectStore('vrms');
				const putReq = store.put(file, 'last');
				putReq.onsuccess = () => { tx.oncomplete = () => { db.close(); resolve(true); }; };
				putReq.onerror = (e) => { db.close(); reject(e); };
			}));

		}

		function getVrmFromIdb() {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readonly');
				const store = tx.objectStore('vrms');
				const getReq = store.get('last');
				getReq.onsuccess = () => { db.close(); resolve(getReq.result); };
				getReq.onerror = (e) => { db.close(); reject(e); };
			}));
		}

		function deleteVrmFromIdb() {
			return openIdb().then(db => new Promise((resolve, reject) => {
				const tx = db.transaction('vrms', 'readwrite');
				const store = tx.objectStore('vrms');
				const delReq = store.delete('last');
				delReq.onsuccess = () => { db.close(); resolve(true); };
				delReq.onerror = (e) => { db.close(); reject(e); };
			}));

		}
		// #endregion IndexedDB Helpers

		// #region Last VRM Persistence
		/**
	 	* Save last VRM reference. For local files, store the blob in IndexedDB and save metadata in localStorage.
	 	 */
		function saveLastVrm(file, url, name) {
			try {
				if (file instanceof File || file instanceof Blob) {
					// Store blob in IndexedDB (no practical size limit beyond browser quota)
					saveVrmToIdb(file).then(() => {
						const entry = { type: 'idb', name: name || (file.name || 'recent.vrm') };
						localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
						statusDiv.textContent = 'Saved last VRM.';
					}).catch((e) => {
						console.warn('Failed to save VRM to IndexedDB:', e);
						// Fallback: save only metadata
						const entry = { type: 'meta', name: name || (file.name || 'recent.vrm') };
						localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
						statusDiv.textContent = 'Last VRM metadata saved (IDB failed).';
					});
				} else {
					// Not a File -> store URL reference
					const entry = { type: 'url', url, name: name || (url && url.split('/').pop()) };
					localStorage.setItem(LAST_VRM_KEY, JSON.stringify(entry));
					statusDiv.textContent = 'Saved last VRM (URL).';
				}
			} catch (e) {
				console.warn('saveLastVrm error:', e);
			}
		}

		/**
		 * Try loading the last VRM stored in localStorage.
		 * Returns true if a load was initiated, false otherwise.
		 */
		async function loadLastVrmFromStorage() {
			try {
				const raw = localStorage.getItem(LAST_VRM_KEY);
				if (!raw) return false;
				const entry = JSON.parse(raw);
				if (!entry) return false;
				if (entry.type === 'idb') {
					// Retrieve blob from IndexedDB
					const file = await getVrmFromIdb();
					if (!file) {
						statusDiv.textContent = 'No VRM found in IndexedDB.';
						return false;
					}
					const url = URL.createObjectURL(file);
					try {
						await loadVRM(url, entry.name || 'recent.vrm', file);
						URL.revokeObjectURL(url);
						return true;
					} catch (e) {
						URL.revokeObjectURL(url);
						throw e;
					}
				} else if (entry.type === 'url' && entry.url) {
					await loadVRM(entry.url, entry.name || (entry.url && entry.url.split('/').pop()));
					return true;
				} else if (entry.type === 'meta') {
					statusDiv.textContent = 'Last VRM was a local file and could not be restored automatically.';
					return false;
				}
			} catch (e) {
				console.warn('Could not load last VRM from storage:', e);
			}
			return false;
		}

		/** Replace currently displayed model with the default VRM file. */
		async function replaceWithDefaultVrm() {
			await loadVRM(VRM_MODEL_URL, 'default.vrm');
		}

		/** Clear the recent VRM entry from localStorage and update header. */
		function clearRecentVrm() {
			localStorage.removeItem(LAST_VRM_KEY);
			// Try to remove blob from IndexedDB as well
			deleteVrmFromIdb().catch(() => { /* ignore */ });
			vrmModelName.textContent = '';
			document.title = 'Figure — VRM & VRMA Model Viewer for Web';
			vrmAuthorName.textContent = '';
			showToast('Recent VRM removed.', 'info');
		}
		// #endregion Last VRM Persistence

		// #region Dispose & Cleanup
		/**
		 * Safely dispose a loaded VRM: geometries, materials, textures and stop mixers.
		 * @param {any} vrm VRM instance returned by the loader
		 */
		function disposeVrm(vrm) {
			if (!vrm) return;

			try {
				// Stop and clear mixer/actions associated with the previous VRM
				if (currentAction) {
					try { currentAction.stop(); } catch (e) { /* ignore */ }
					currentAction = undefined;
				}
				if (currentMixer) {
					try { currentMixer.stopAllAction(); } catch (e) { /* ignore */ }
					currentMixer = undefined;
				}

				// Traverse scene and dispose geometries/materials/textures
				if (vrm.scene) {
					vrm.scene.traverse((obj) => {
						if (obj.isMesh) {
							if (obj.geometry) {
								try { obj.geometry.dispose(); } catch (e) { /* ignore */ }
							}
							if (obj.material) {
								const disposeMaterial = (material) => {
									if (!material) return;
									if (material.map) {
										try { material.map.dispose(); } catch (e) { /* ignore */ }
									}
									if (material.dispose) {
										try { material.dispose(); } catch (e) { /* ignore */ }
									}
								};

								if (Array.isArray(obj.material)) {
									obj.material.forEach(disposeMaterial);
								} else {
									disposeMaterial(obj.material);
								}
							}
						}
					});
				}

				// If loader attached any extra resources on vrm, try to null them
				try { if (vrm.userData) vrm.userData = null; } catch (e) { }
			} catch (e) {
				console.warn('Error while disposing VRM:', e);
			}
		}
		// #endregion Dispose & Cleanup

		// #region Loader Plugins
		// --- GLTF Loader with VRM and VRMA Plugins ---
		const loader = new GLTFLoader();
		loader.crossOrigin = 'anonymous';

		loader.register((parser) => {
			return new VRMLoaderPlugin(parser);
		});

		loader.register((parser) => {
			return new VRMAnimationLoaderPlugin(parser);
		});
		// #endregion Loader Plugins

		// #region File Paths
		// --- File Paths ---
		const VRM_MODEL_URL = './VRM/default.vrm'; // Fixed VRM model path (relative path)
		// VRMA animations dictionary: map an id/key (used by buttons) to URL
		const VRMA_ANIMATIONS = {
			// 'Angry'       : './VRMA/tk256ailab/Angry.vrma',
			// 'Blush'       : './VRMA/tk256ailab/Blush.vrma',
			// 'Clapping'    : './VRMA/tk256ailab/Clapping.vrma',
			// 'Goodbye'     : './VRMA/tk256ailab/Goodbye.vrma',
			// 'Jump'        : './VRMA/tk256ailab/Jump.vrma',
			// 'LookAround'  : './VRMA/tk256ailab/LookAround.vrma',
			// 'Relax'       : './VRMA/tk256ailab/Relax.vrma',
			// 'Sad'         : './VRMA/tk256ailab/Sad.vrma',
			// 'Sleepy'      : './VRMA/tk256ailab/Sleepy.vrma',
			// 'Surprised'   : './VRMA/tk256ailab/Surprised.vrma',
			// 'Thinking'    : './VRMA/tk256ailab/Thinking.vrma',
			'Show Full Body' : './VRMA/VRoid Project/ShowFullBody.vrma',
			'Greeting'       : './VRMA/VRoid Project/Greeting.vrma',
			'Peace Sign'     : './VRMA/VRoid Project/PeaceSign.vrma',
			'Shoot'          : './VRMA/VRoid Project/Shoot.vrma',
			'Spin'           : './VRMA/VRoid Project/Spin.vrma',
			'Model Pose'     : './VRMA/VRoid Project/ModelPose.vrma',
			'Squat'          : './VRMA/VRoid Project/Squat.vrma',

			'Standard'       : './VRMA/VRoid Hub/Standard.vrma',
			'Innocent'       : './VRMA/VRoid Hub/Innocent.vrma',
			'Cool'           : './VRMA/VRoid Hub/Cool.vrma',
			'Ladylike'       : './VRMA/VRoid Hub/Ladylike.vrma',
			'Shy'            : './VRMA/VRoid Hub/Shy.vrma',
			'Energetic'      : './VRMA/VRoid Hub/Energetic.vrma',
			'Flamboyant'     : './VRMA/VRoid Hub/Flamboyant.vrma',
			'Gentleman'      : './VRMA/VRoid Hub/Gentleman.vrma',
			'Powerful'       : './VRMA/VRoid Hub/Powerful.vrma'
		};

		// Separate dictionary for single-frame poses (kept separate for organization)
		const VRMA_POSES = {
			'test': './VRMA_POSES/angry.vrma',
		};
		// #endregion File Paths

		// #region File Loading
		// --- File Loading Functions ---
		/**
		 * Loads a VRM model from a specified URL.
		 * @param {string} url The URL of the VRM file.
		 * @returns {Promise<any>} A promise that resolves with the loaded VRM.
		 */
		async function loadVRM(url, displayName, fileObject) {
			try {
				showToast('Loading VRM model', 'folder_shared');

				return new Promise((resolve, reject) => {
					loader.load(
						url,
						(gltf) => {
							const vrm = gltf.userData.vrm;

							// Apply performance optimizations
							VRMUtils.removeUnnecessaryVertices(gltf.scene);
							VRMUtils.combineSkeletons(gltf.scene);
							VRMUtils.combineMorphs(vrm);

							// Disable frustum culling for all objects in the VRM scene
							vrm.scene.traverse((obj) => {
								obj.frustumCulled = false;
							});

							// Remove previous VRM if one is loaded
							if (currentVrm) {
								scene.remove(currentVrm.scene);
								// Safely dispose of geometries/materials/textures and stop mixers
								disposeVrm(currentVrm);
								currentVrm = undefined;
							}

							scene.add(vrm.scene);
							if (vrm.meta.metaVersion == '0') {
								vrm.scene.rotation.y = Math.PI; // VRM 0.x
							} else {
								vrm.scene.rotation._y = Math.PI; // VRM 1.x
							}
							currentVrm = vrm;

							// Create a new AnimationMixer for the current VRM
							currentMixer = new THREE.AnimationMixer(vrm.scene);

							// Update header with model name when provided
							if (displayName) {
								vrmModelName.textContent = currentVrm.meta.title || currentVrm.meta.name || displayName;
								document.title = vrmModelName.textContent + ' - Figure';
								vrmAuthorName.textContent = currentVrm.meta.author || 'Unknown author';
							}

							// Adjust ground shadow size and position to match model bounds
							try {
								if (groundShadow) {
									const box = new THREE.Box3().setFromObject(vrm.scene);
									const size = box.getSize(new THREE.Vector3());
									const maxDim = Math.max(size.x, size.z, 0.8);
									const scale = maxDim * 1.4; // slightly larger than footprint
									groundShadow.scale.set(scale, scale, 1);
									groundShadow.position.x = vrm.scene.position.x;
									groundShadow.position.z = vrm.scene.position.z;
								}
							} catch (e) { /* ignore bounding errors */ }

							showToast('Model loaded successfully!', 'person_check');
							console.log('VRM loaded:', vrm);

							updateButtons();

							// Try to populate thumbnail from glTF images (safe path: uri or bufferView)
							try {
								const metaObj = currentVrm.meta || {};
								const hasThumb = metaObj.thumbnailImage || metaObj.texture || metaObj.thumbnail || metaObj.icon;
								if (!hasThumb && gltf && gltf.parser && gltf.parser.json && Array.isArray(gltf.parser.json.images)) {
									const imgs = gltf.parser.json.images;
									let idx = imgs.findIndex(im => im && ((im.name && /thumbnail/i.test(im.name)) || (im.uri && /thumbnail/i.test(im.uri))));
									if (idx === -1) idx = imgs.findIndex(im => im && (im.name && /thumb/i.test(im.name)));
									if (idx >= 0) {
										const info = imgs[idx];
										if (info.uri) {
											// Resolve relative URIs against model URL
											let src = info.uri;
											try { src = new URL(info.uri, url).href; } catch (_) { /* ignore */ }
											const img = new Image();
											img.crossOrigin = 'Anonymous';
											img.onload = () => {
												if (!currentVrm.meta) currentVrm.meta = {};
												currentVrm.meta.icon = { image: img };
												updateFavicon();
											};
											img.onerror = () => { /* ignore load errors */ };
											img.src = src;
										} else if (info.bufferView !== undefined) {
											// load raw bufferView and create blob URL without using getDependency('image')
											const bvIndex = info.bufferView;
											gltf.parser.getDependency('bufferView', bvIndex).then((arrayBuffer) => {
												try {
													const mime = info.mimeType || 'image/png';
													const blob = new Blob([arrayBuffer], { type: mime });
													const objUrl = URL.createObjectURL(blob);
													const img = new Image();
													img.crossOrigin = 'Anonymous';
													img.onload = () => {
														URL.revokeObjectURL(objUrl);
														if (!currentVrm.meta) currentVrm.meta = {};
														currentVrm.meta.icon = { image: img };
														updateFavicon();
													};
													img.onerror = () => { URL.revokeObjectURL(objUrl); };
													img.src = objUrl;
												} catch (e) { /* ignore */ }
										}).catch(() => { /* ignore bufferView errors */ });
										}
									}
								}
							} catch (e) { console.warn('thumbnail extraction failed (safe):', e); }
							// call updateFavicon immediately to set fallback; async image load may replace it
							updateFavicon();

							// Populate blend shape controls for the loaded VRM
							try { populateBlendShapeControls(); } catch (e) { console.warn('populateBlendShapeControls failed:', e); }

							// Populate materials list
							try { populateMaterials(); } catch (e) { console.warn('populateMaterials failed:', e); }

							// Save last VRM reference to localStorage (attempt to persist)
							try { saveLastVrm(fileObject, url, displayName || (url && url.split('/').pop())); } catch (e) { console.warn(e); }

							resolve(vrm);
						},
						(progress) => {
							const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
							statusDiv.textContent = `Loading VRM model... ${percent}%`;
						},
						(error) => {
							console.error('Error loading VRM:', error);
							statusDiv.textContent = 'An error occurred while loading the VRM model';
							reject(error);
						}
					);
				});
			} catch (error) {
				console.error('Error in loadVRM:', error);
				statusDiv.textContent = 'An error occurred while loading the VRM model';
			}
		}

		/**
		 * Loads a VRMA animation from a specified URL and converts it to a THREE.AnimationClip.
		 * @param {string} url The URL of the VRMA file.
		 * @returns {Promise<THREE.AnimationClip>} A promise that resolves with the generated AnimationClip.
		 */
		async function loadVRMA(url, displayName) {
			if (!currentVrm) {
				statusDiv.textContent = 'VRM model not loaded. Please load the VRM model first.';
				return;
			}

			try {
				statusDiv.textContent = 'Loading VRMA animation...';

				return new Promise((resolve, reject) => {
					loader.load(
						url,
						(gltf) => {
							console.log('GLTF loaded (VRMA):', gltf);

							// gltf.userData.vrmAnimations[0] contains the raw VRMAnimation data object
							const vrmAnimationData = gltf.userData.vrmAnimations && gltf.userData.vrmAnimations[0];

							if (vrmAnimationData) {
								// Call the standalone createVRMAnimationClip function
								// It takes the VRMAnimation data object and the current VRM model
								const clip = createVRMAnimationClip(vrmAnimationData, currentVrm);

								if (clip) {
									vrmaAnimationClip = clip;

									statusDiv.textContent = 'Animation loaded successfully!';
									console.log('Generated AnimationClip:', vrmaAnimationClip);

									updateButtons(); // Enable play/pause/stop after animation is loaded

									// Auto-play the animation when loaded
									try {
										playAnimation();
									} catch (e) {
										console.warn('Auto-play failed:', e);
									}

									resolve(vrmaAnimationClip);
								} else {
									throw new Error('Failed to create AnimationClip from VRMA data.');
								}
							} else {
								throw new Error('No valid VRMA animation found in the file.');
							}
						},
						(progress) => {
							const percent = (100.0 * (progress.loaded / progress.total)).toFixed(1);
							statusDiv.textContent = `Loading VRMA animation... ${percent}%`;
						},
						(error) => {
							console.error('Error loading animation:', error);
							statusDiv.textContent = 'An error occurred while loading the animation file: ' + error.message;
							reject(error);
						}
					);
				});
			} catch (error) {
				console.error('Error in loadVRMA:', error);
				statusDiv.textContent = 'An error occurred while loading the animation file';
			}
		}
		// #endregion File Loading

		// #region Animation Controls
		// --- Animation Control Functions ---
		/**
		 * Starts playing the loaded VRMA animation.
		 */
		function playAnimation() {
			if (currentVrm && vrmaAnimationClip && currentMixer) {
				// Stop any currently playing action
				if (currentAction) {
					currentAction.stop();
				}

				try {
					console.log('Playing animation...');

					// Create and configure animation action from the generated clip
					currentAction = currentMixer.clipAction(vrmaAnimationClip);
					currentAction.setLoop(THREE.LoopRepeat); // Loop the animation
					currentAction.clampWhenFinished = true; // Stay at the last frame when finished
					currentAction.reset(); // Reset to the start of the animation
					currentAction.play(); // Start playing

					statusDiv.textContent = `Playing animation (${vrmaAnimationClip.tracks.length} tracks, ${vrmaAnimationClip.duration.toFixed(2)}s)`;
					// update toggle icon if present
					setPlayPauseIcon(true);
					console.log('Animation started successfully.');
				} catch (error) {
					console.error('Error playing animation:', error);
					statusDiv.textContent = 'An error occurred while playing the animation: ' + error.message;
				}
			} else {
				statusDiv.textContent = 'A VRM model and animation must be loaded.';
			}
		}

		/**
		 * Toggles the pause state of the animation.
		 */
		function pauseAnimation() {
			if (currentAction) {
				currentAction.paused = !currentAction.paused;
				statusDiv.textContent = currentAction.paused ? 'Animation paused' : 'Animation playing...';
				setPlayPauseIcon(!currentAction.paused);
			}
		}

		/**
		 * Stops the animation and resets the model's pose.
		 */
		function stopAnimation() {
			if (currentAction) {
				currentAction.stop();
				currentAction = undefined;
				currentMixer.stopAllAction(); // Stop all actions on the mixer

				// Reset VRM pose (optional, but good for stopping)
				if (currentVrm) {
					currentVrm.humanoid.resetPose();
				}
				// reset play/pause icon to play
				setPlayPauseIcon(false);
			}
		}
		// #endregion Animation Controls

		// #region UI & Events
		// --- UI and Event Handlers ---
		/**
		 * Updates the state of the control buttons based on loaded files.
		 */
		function updateButtons() {
			const hasVrm = currentVrm !== undefined;
			const hasVrma = vrmaAnimationClip !== undefined;

			// Enable VRMA selection buttons once VRM is loaded
			const vrmaBtns = document.querySelectorAll('.vrma-btn');
			vrmaBtns.forEach(btn => { btn.disabled = !hasVrm; });

			// Enable play/pause and stop buttons only if both VRM and an animation are loaded
			if (playPauseBtn) playPauseBtn.disabled = !(hasVrm && hasVrma);
			stopBtn.disabled = !(hasVrm && hasVrma);

			// enable/disable selects
			if (animationSelect) animationSelect.disabled = !hasVrm;
			if (poseSelect) poseSelect.disabled = !hasVrm;
		}

		function updateFavicon() {
			const link = document.querySelector("link[rel~='icon']") || document.createElement('link');
			link.rel = 'icon';
			if (currentVrm && currentVrm.meta && currentVrm.meta.icon) {
				// Convert the VRM icon (THREE.Texture) to a data URL
				const canvas = document.createElement('canvas');
				canvas.width = currentVrm.meta.icon.image.width;
				canvas.height = currentVrm.meta.icon.image.height;
				const ctx = canvas.getContext('2d');
				ctx.drawImage(currentVrm.meta.icon.image, 0, 0);
				link.href = canvas.toDataURL('image/png');
			} else {
				// Fallback to default favicon
				link.href = './static/favicon.svg';
			}
			document.getElementsByTagName('head')[0].appendChild(link);
		}

		// Add event listeners for VRMA animation buttons (lookup by key instead of array index)
		function normalizeKey(s) { return String(s || '').toLowerCase().replace(/[^a-z0-9]/g, ''); }
		const animationKeys = Object.keys(VRMA_ANIMATIONS || {});
		const normalizedMap = {};
		animationKeys.forEach(k => { normalizedMap[normalizeKey(k)] = VRMA_ANIMATIONS[k]; });

		// Populate VRMA buttons dynamically from the VRMA_ANIMATIONS dictionary
		function populateVrmaButtons() {
			const container = document.querySelector('#vrmaButtons .item-group-content');
			if (!container) return;
			container.innerHTML = '';
			const keys = Object.keys(VRMA_ANIMATIONS || {});
			keys.forEach(k => {
				const url = VRMA_ANIMATIONS[k];
				const clean = String(url).replace(/^\.\/+/, '');
				const parts = clean.split('/');
				const folder = parts.length >= 2 ? parts[1] : '';

				const btn = document.createElement('button');
				btn.className = 'item vrma-btn';
				btn.disabled = true; // will be enabled by updateButtons when VRM loaded
				btn.dataset.key = k;
				btn.setAttribute('translate', 'no');

				const inner = document.createElement('div');
				inner.style.width = '90%';
				const strong = document.createElement('strong');
				strong.textContent = k + ' ';
				const span = document.createElement('span');
				span.textContent = folder ? ('by ' + folder) : '';
				inner.appendChild(strong);
				inner.appendChild(span);
				btn.appendChild(inner);

				btn.addEventListener('click', async () => {
					if (currentAction) { try { currentAction.stop(); } catch (e) { } currentAction = undefined; }
					vrmaAnimationClip = undefined;
					const key = btn.dataset.key || btn.textContent.trim();
					const n = normalizeKey(key);
					let url2 = normalizedMap[n];
					if (!url2) {
						for (const kk of keys) {
							if (normalizeKey(kk) === n) { url2 = VRMA_ANIMATIONS[kk]; break; }
						}
					}
					if (!url2) {
						statusDiv.textContent = 'Animation not found for ' + key;
						console.warn('No VRMA mapping for button key:', key);
						return;
					}
					await loadVRMA(url2, url2.split('/').pop());
					if (isMobile()) document.getElementById('controls-bar').classList.remove('show');
				});

				container.appendChild(btn);
			});
		}

		// Build the buttons now
		populateVrmaButtons();

		// Populate selects for animations and poses
		function populateAnimationSelect() {
			if (!animationSelect) return;
			animationSelect.innerHTML = '';
			const keys = Object.keys(VRMA_ANIMATIONS || {});
			animationSelect.appendChild(document.createElement('option')); // empty option
			keys.forEach(k => {
				const opt = document.createElement('option');
				opt.value = k;
				opt.textContent = k;
				animationSelect.appendChild(opt);
			});
			animationSelect.disabled = keys.length === 0 || !currentVrm;
		}

		function populatePoseSelect() {
			if (!poseSelect) return;
			poseSelect.innerHTML = '';
			const keys = Object.keys(VRMA_POSES || {});
			poseSelect.appendChild(document.createElement('option')); // empty option
			keys.forEach(k => {
				const opt = document.createElement('option');
				opt.value = k;
				opt.textContent = k;
				poseSelect.appendChild(opt);
			});
			poseSelect.disabled = keys.length === 0 || !currentVrm;
		}

		// Wire select handlers
		if (animationSelect) {
			animationSelect.addEventListener('change', async (e) => {
				const key = e.target.value;
				if (!key) return;
				const url = VRMA_ANIMATIONS[key];
				if (!url) return;
				vrmaAnimationClip = undefined;
				await loadVRMA(url, url.split('/').pop());
				// auto-play handled by loadVRMA
				// reset poseSelect to empty
				if (poseSelect) poseSelect.value = '';
			});
		}

		if (poseSelect) {
			poseSelect.addEventListener('change', async (e) => {
				const key = e.target.value;
				if (!key) return;
				const url = VRMA_POSES[key];
				if (!url) return;
				// load pose as a clip and apply single-frame pose
				try {
					const clip = await loadVRMA(url, url.split('/').pop());
					if (!clip || !currentMixer) return;
					// create an action and step to first frame then pause
					const action = currentMixer.clipAction(clip);
					action.reset();
					action.play();
					// clamp and pause so pose remains
					action.clampWhenFinished = true;
					action.paused = true;
					try { currentMixer.update(0); } catch (e) { /* ignore */ }
					// reset animationSelect to empty
					if (animationSelect) animationSelect.value = '';
				} catch (err) {
					console.warn('Failed to apply pose:', err);
				}
			});
		}

		// initial populate
		populateAnimationSelect();
		populatePoseSelect();

		// #region Look controls
		function createLookControls() {
			const joystick = document.getElementById('look_joystick');
			const handle = document.getElementById('look_joystick_handle');
			const followChk = document.getElementById('look_follow_camera');
			if (!joystick || !handle || !followChk) return;

			let dragging = false;
			let rect = null;
			const maxRange = 2.0;
			const maxYaw = 2.0;
			const maxPitch = 2.0;
			const pos = { x: 0, y: 0 };

			function updateHandleFromPos() {
				const h = handle;
				const cx = (joystick.clientWidth - h.clientWidth) / 2;
				const cy = (joystick.clientHeight - h.clientHeight) / 2;
				const left = cx + pos.x * cx;
				const top = cy + pos.y * cy;
				h.style.left = Math.round(left) + 'px';
				h.style.top = Math.round(top) + 'px';
			}

			function setPosFromClient(clientX, clientY) {
				if (!rect) rect = joystick.getBoundingClientRect();
				const x = ((clientX - rect.left) / rect.width) * 2 - 1;
				const y = ((clientY - rect.top) / rect.height) * 2 - 1;
				// clamp
				pos.x = Math.max(-1, Math.min(1, x));
				pos.y = Math.max(-1, Math.min(1, y));
				updateHandleFromPos();
				// apply to VRM if not following camera
				if (!followChk.checked) applyJoystickToLook(pos.x, pos.y, maxYaw, maxPitch);
			}

			joystick.addEventListener('pointerdown', (e) => {
				dragging = true; rect = joystick.getBoundingClientRect(); joystick.setPointerCapture(e.pointerId);
				setPosFromClient(e.clientX, e.clientY);
			});
			window.addEventListener('pointermove', (e) => {
				if (!dragging) return;
				setPosFromClient(e.clientX, e.clientY);
			});
			window.addEventListener('pointerup', (e) => {
				if (!dragging) return; dragging = false; rect = null;
				if (!followChk.checked) applyJoystickToLook(pos.x, pos.y, maxYaw, maxPitch);
			});

			followChk.addEventListener('change', () => {
				// when enabling follow camera, joystick is disabled visually
				if (followChk.checked) {
					handle.style.opacity = '0.4';
					joystick.style.pointerEvents = 'none';
					// enable lookAt target to follow the camera
					if (currentVrm && currentVrm.lookAt) {
						currentVrm.lookAt.target = camera;
						currentVrm.lookAt.autoUpdate = true;
					}
				} else {
					handle.style.opacity = '1';
					applyJoystickToLook(pos.x, pos.y, maxYaw, maxPitch);
					joystick.style.pointerEvents = 'auto';
					// disable lookAt target so manual control is preserved
					if (currentVrm && currentVrm.lookAt) {
						currentVrm.lookAt.target = null;
						currentVrm.lookAt.autoUpdate = false;
					}
				}
			});
		}

		function applyJoystickToLook(nx, ny, maxYaw, maxPitch) {
			if (!currentVrm || !currentVrm.lookAt) return;
			try {
				const yaw = nx * (maxYaw || 0.9);
				const pitch = ny * (maxPitch || 0.6);
				const yawDeg = THREE.MathUtils.radToDeg(yaw);
				const pitchDeg = THREE.MathUtils.radToDeg(pitch);
				// disable autoUpdate so manual control is preserved
				if (currentVrm.lookAt) currentVrm.lookAt.autoUpdate = false;
				currentVrm.lookAt.yaw = yawDeg;
				currentVrm.lookAt.pitch = pitchDeg;
				// console.log('applyJoystickToLook', { yaw: yawDeg, pitch: pitchDeg });
				if (typeof currentVrm.lookAt.update === 'function') {
					try { currentVrm.lookAt.update(0); } catch(e){ console.warn('lookAt.update failed', e); }
				}
			} catch (e) { /* ignore */ }
		}

		// helper to find bone by common names
		function findBoneByNames(names) {
			if (!currentVrm || !currentVrm.scene) return null;
			for (const n of names) {
				let byName = currentVrm.scene.getObjectByName(n);
				if (byName) return byName;
			}
			// fallback: search by substring
			let found = null;
			currentVrm.scene.traverse(obj => { if (!found && obj.name && names.some(s=>obj.name.indexOf(s)>=0)) found = obj; });
			return found;
		}

		function setBoneLookAt(bone, targetVec3, weight = 0.6) {
			if (!bone) return;
			const boneWorldPos = bone.getWorldPosition(new THREE.Vector3());
			const m = new THREE.Matrix4();
			m.lookAt(boneWorldPos, targetVec3, bone.up || new THREE.Vector3(0,1,0));
			const targetWorldQuat = new THREE.Quaternion().setFromRotationMatrix(m);
			const parent = bone.parent;
			let parentWorldQuat = new THREE.Quaternion();
			if (parent) parent.getWorldQuaternion(parentWorldQuat); else parentWorldQuat.identity();
			const parentWorldQuatInv = parentWorldQuat.clone().invert();
			const targetLocalQuat = parentWorldQuatInv.multiply(targetWorldQuat);
			bone.quaternion.slerp(targetLocalQuat, weight);
		}

		function updateLookControl(delta) {
			// priority: follow camera checkbox -> joystick
			const follow = document.getElementById('look_follow_camera');
			if (!currentVrm || !currentVrm.lookAt) return;
			if (follow && follow.checked) {
				// compute yaw/pitch towards camera from head bone
				let headBone = findBoneByNames(['J_Bip_C_Head','Head','head']);
				if (!headBone && currentVrm.humanoid && currentVrm.humanoid.getBoneNode) {
					try { headBone = currentVrm.humanoid.getBoneNode('head'); } catch(e){}
				}
				const headPos = headBone ? headBone.getWorldPosition(new THREE.Vector3()) : currentVrm.scene.getWorldPosition(new THREE.Vector3());
				const dir = camera.position.clone().sub(headPos).normalize();
				let headQuat = new THREE.Quaternion(); if (headBone) headBone.getWorldQuaternion(headQuat); else headQuat.identity();
				const inv = headQuat.clone().invert();
				const localDir = dir.clone().applyQuaternion(inv);
				const yaw = Math.atan2(localDir.x, localDir.z);
				const pitch = Math.atan2(-localDir.y, Math.sqrt(localDir.x*localDir.x + localDir.z*localDir.z));
				const yawDeg = THREE.MathUtils.radToDeg(yaw);
				const pitchDeg = THREE.MathUtils.radToDeg(pitch);
				currentVrm.lookAt.yaw = yawDeg;
				currentVrm.lookAt.pitch = pitchDeg;
				// console.log('updateLookControl follow-camera', { yaw: yawDeg, pitch: pitchDeg });
				if (typeof currentVrm.lookAt.update === 'function') {
					try { currentVrm.lookAt.update(delta || 0); } catch(e) { console.warn('lookAt.update failed', e); }
				}
			}
		}

		const resetLookBtn = document.getElementById('resetLookBtn');
		if (resetLookBtn) { resetLookBtn.addEventListener('click', resetLookControls); }

		function resetLookControls() {
			const joystick = document.getElementById('look_joystick');
			const handle = document.getElementById('look_joystick_handle');
			const followChk = document.getElementById('look_follow_camera');
			
			if (!currentVrm || !currentVrm.lookAt) return;
			currentVrm.lookAt.yaw = 0;
			currentVrm.lookAt.pitch = 0;
			if (typeof currentVrm.lookAt.update === 'function') {
				try { currentVrm.lookAt.update(0); } catch(e) { console.warn('lookAt.update failed', e); }
			}

			// reset joystick position
			if (handle && joystick) {
				handle.style.left = ((joystick.clientWidth - handle.clientWidth) / 2) + 'px';
				handle.style.top = ((joystick.clientHeight - handle.clientHeight) / 2) + 'px';
				currentVrm.lookAt.yaw = 0;
				currentVrm.lookAt.pitch = 0;
			}
			// uncheck follow camera
			if (followChk) {
				followChk.checked = false;
				currentVrm.lookAt.autoUpdate = false;

				// re-enable joystick interaction, in case it was disabled
				handle.style.opacity = '1';
				applyJoystickToLook(pos.x, pos.y, maxYaw, maxPitch);
				joystick.style.pointerEvents = 'auto';
				// disable lookAt target so manual control is preserved
				if (currentVrm && currentVrm.lookAt) {
					currentVrm.lookAt.target = null;
					currentVrm.lookAt.autoUpdate = false;
				}
				currentVrm.lookAt.yaw = 0;
				currentVrm.lookAt.pitch = 0;
			}
		}

		const resetExpressionBtn = document.getElementById('resetExpressionBtn');
		if (resetExpressionBtn) { resetExpressionBtn.addEventListener('click', resetExpressionControls); }

		function resetExpressionControls() {
			const container = document.getElementById('blendShapeRanges');
			if (container) {
				const inputs = container.querySelectorAll('input[type="range"]');
				inputs.forEach(input => {
					input.value = '0';
					const blendshapeName = input.id.replace('blend_', '');
					applyBlendShape(blendshapeName, 0);
				});
			}
		}

		// instantiate look controls
		createLookControls();

		// #endregion Look controls

		// Toggle play/pause button handler
		function setPlayPauseIcon(isPlaying) {
			if (!playPauseBtn) return;
			playPauseBtn.textContent = isPlaying ? 'pause' : 'play_arrow';
		}

		function togglePlayPause() {
			if (!currentVrm || !vrmaAnimationClip) {
				statusDiv.textContent = 'A VRM model and animation must be loaded.';
				return;
			}
			// If no action, start playing
			if (!currentAction) {
				playAnimation();
				setPlayPauseIcon(true);
				return;
			}
			// Toggle paused state
			currentAction.paused = !currentAction.paused;
			setPlayPauseIcon(!currentAction.paused);
		}

		if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);
		stopBtn.addEventListener('click', stopAnimation);

		// Reset camera button
		const resetCameraBtn = document.getElementById('resetCameraBtn');
		let resetCameraAnimId = null;
		// Ease in-out quad
		function easeInOutQuad(t) {
			return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
		}
		function smoothResetCamera(duration = 600) {
			if (resetCameraAnimId) cancelAnimationFrame(resetCameraAnimId);
			const startPos = camera.position.clone();
			const startTarget = controls.target.clone();
			const endPos = DEFAULT_CAMERA_POSITION.clone();
			const endTarget = DEFAULT_CONTROLS_TARGET.clone();
			const startTime = performance.now();

			function step(now) {
				const elapsed = now - startTime;
				let t = Math.min(1, elapsed / duration);
				const e = easeInOutQuad(t);
				camera.position.lerpVectors(startPos, endPos, e);
				controls.target.lerpVectors(startTarget, endTarget, e);
				controls.update();
				if (t < 1) {
					resetCameraAnimId = requestAnimationFrame(step);
				} else {
					resetCameraAnimId = null;
				}
			}

			resetCameraAnimId = requestAnimationFrame(step);
		}

		if (resetCameraBtn) resetCameraBtn.addEventListener('click', () => smoothResetCamera(600));

		if (modelInfoBtn) {
			modelInfoBtn.addEventListener('mouseup', () => {
				closeAllDialogs();
				hideAllMenus();
				showVRMMeta(currentVrm);
			});
		}

		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});

		// --- Drag-and-Drop File Support ---
		// Allow users to drop a .vrm or .vrma file onto the preview area (`mainWrapper`).
		async function handleFileDrop(file) {
			if (!file) return;
			const name = file.name || '';
			const lname = name.toLowerCase();

			if (lname.endsWith('.vrm')) {
				const url = URL.createObjectURL(file);
				try {
					await loadVRM(url, file.name, file);
				} catch (e) {
					console.error('Failed to load dropped VRM:', e);
				} finally {
					URL.revokeObjectURL(url);
				}
			} else if (lname.endsWith('.vrma')) {
				const url = URL.createObjectURL(file);
				try {
					await loadVRMA(url, file.name);
				} catch (e) {
					console.error('Failed to load dropped VRMA:', e);
				} finally {
					URL.revokeObjectURL(url);
				}
			} else {
				showToast('File not supported', 'error');
			}
		}

		mainWrapper.addEventListener('dragover', (e) => {
			e.preventDefault();
			e.dataTransfer.dropEffect = 'copy';
			const bodyBg = getComputedStyle(document.body).getPropertyValue('--color-blue-bg').trim();
			const rootBg = getComputedStyle(document.documentElement).getPropertyValue('--color-blue-bg').trim();
			const cssBg = bodyBg || rootBg || '#222222';
			scene.background = new THREE.Color(cssBg);
		});

		mainWrapper.addEventListener('dragleave', (e) => {
			e.preventDefault();
			const bodyBg = getComputedStyle(document.body).getPropertyValue('--background-color-2').trim();
			const rootBg = getComputedStyle(document.documentElement).getPropertyValue('--background-color-2').trim();
			const cssBg = bodyBg || rootBg || '#222222';
			scene.background = new THREE.Color(cssBg);
		});

		mainWrapper.addEventListener('drop', async (e) => {
			e.preventDefault();
			const dt = e.dataTransfer;
			if (!dt) return;
			const file = dt.files && dt.files[0];
			await handleFileDrop(file);
		});

		document.body.addEventListener('keydown', async (e) => {
			if (e.key == 'r') {
				smoothResetCamera(600);
			}
			if (e.key == 'p') {
				togglePlayPause();
				if (currentAction && currentAction.paused) {
					showToast('Animation paused', 'pause');
				} else {
					showToast('Animation playing', 'play_arrow');
				}
			}
			if (e.key == 'F1') {
				showMessageFromFile('dialog/about.html');
				closeAllDialogs();
				hideAllMenus();
			}
		});

		// --- Helpers ---
		// const gridHelper = new THREE.GridHelper(10, 10);
		// scene.add(gridHelper);

		// const axesHelper = new THREE.AxesHelper(5);
		// scene.add(axesHelper);

		/**
		 * Create a circular ground shadow using a canvas radial gradient texture.
		 * @param {number} size Base diameter in world units
		 */
		function createGroundShadow(size = 1) {
			const sizePx = 1024;
			const canvas = document.createElement('canvas');
			canvas.width = sizePx;
			canvas.height = sizePx;
			const ctx = canvas.getContext('2d');
			// radial gradient from center (opaque) to transparent at edge
			const cx = sizePx / 2, cy = sizePx / 2, r = sizePx / 2;
			const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
			g.addColorStop(0, '#00000033');
			g.addColorStop(1, '#00000000');
			ctx.fillStyle = g;
			ctx.fillRect(0, 0, sizePx, sizePx);

			const tex = new THREE.CanvasTexture(canvas);
			tex.encoding = THREE.sRGBEncoding;
			tex.needsUpdate = true;

			const geom = new THREE.PlaneGeometry(0.5, 0.5);
			const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
			const mesh = new THREE.Mesh(geom, mat);
			mesh.rotation.x = -Math.PI / 2; // lie flat on XZ plane
			mesh.renderOrder = 999;
			mesh.receiveShadow = false;
			mesh.position.y = 0.001; // slightly above ground to avoid z-fighting
			mesh.scale.set(size, size, 1);
			scene.add(mesh);
			return mesh;
		}

		// instantiate the ground shadow
		groundShadow = createGroundShadow(1);

		// #endregion UI & Events

		// #region Blend Shape Controls
		const BLENDSHAPE_ORDER = [
			// neutral
			'neutral',

			// vocals (phonetical japanese)
			'a', 'i', 'u', 'e', 'o',

			// eyes
			'blink', 'blink_r', 'blink_l',

			// universal vrm expressions
			'angry', 'fun', 'joy', 'sorrow',
		];

		/**
		 * Normalize blendshape names to a canonical form
		 * to guarantee stable matching across VRM / VRoid variations.
		 */
		function normalizeBlendShapeName(name) {
			return name
				.toLowerCase()
				.trim()
				.replace(/\s+/g, '')
				.replace(/-/g, '_')
				.replace(/_?left$/, '_l')
				.replace(/_?right$/, '_r');
		}

		/**
		 * Apply a blend shape value (0-100) to the current VRM.
		 */
		function applyBlendShape(key, value100) {
			if (!currentVrm) return;
			const v = Math.max(0, Math.min(100, Number(value100))) / 100.0;
			currentVrm.expressionManager.setValue(key, v);
		}

		/**
		 * Sort blendshape names:
		 * 1. Fixed VRM order
		 * 2. Custom expressions (alphabetical)
		 */
		function sortBlendShapeNames(names) {
			const nameMap = new Map();

			// index detected names using normalized keys
			names.forEach(name => {
				nameMap.set(normalizeBlendShapeName(name), name);
			});

			const result = [];

			// push fixed expressions strictly in canonical order
			BLENDSHAPE_ORDER.forEach(key => {
				if (nameMap.has(key)) {
					result.push(nameMap.get(key));
					nameMap.delete(key);
				}
			});

			// remaining expressions are custom → alphabetical
			const custom = Array.from(nameMap.values()).sort((a, b) =>
				a.localeCompare(b)
			);

			return result.concat(custom);
		}

		/**
		 * Build and attach blend shape range controls into the blendShapeRanges content area.
		 */
		function populateBlendShapeControls() {
			const container = document.getElementById('blendShapeRanges')
			if (!container) return;
			container.innerHTML = '';

			if (!currentVrm) return;

			// collect morph target names from meshes
			const names = new Set();
			currentVrm.scene.traverse(obj => {
				if (!obj.isMesh || !obj.morphTargetDictionary) return;
				Object.keys(obj.morphTargetDictionary).forEach(n => names.add(n));
			});

			// collect blendshape proxy names (best effort)
			try {
				if (currentVrm.blendShapeProxy) {
					if (Array.isArray(currentVrm.blendShapeProxy.expressions)) {
						currentVrm.blendShapeProxy.expressions.forEach(e => {
							if (e?.name) names.add(e.name);
						});
					}
					if (currentVrm.blendShapeProxy._binds) {
						Object.keys(currentVrm.blendShapeProxy._binds).forEach(k => names.add(k));
					}
				}
			} catch (_) {}

			// build UI controls in correct order
			sortBlendShapeNames(Array.from(names)).forEach(name => {
				const subcontainer = document.createElement('div');
				subcontainer.className = 'setting switch-wrapper';
				// add 'top' class to first item
				if (container.children.length === 0) {
					subcontainer.classList.add('top');
				}
				// add 'bottom' class to last item
				if (container.children.length === names.size - 1) {
					subcontainer.classList.add('bottom');
				}

				const label = document.createElement('span');
				label.textContent = name;
				label.className = 'switch-text';

				const input = document.createElement('input');
				input.type = 'range';
				input.min = 0;
				input.max = 100;
				input.value = 0;

				input.id = 'blend_' + name.replace(/[^a-z0-9]/gi, '_');

				input.addEventListener('input', e =>
					applyBlendShape(name, e.target.value)
				);

				// initialize slider value
				let initVal = 0;
				try {
					if (currentVrm.blendShapeProxy?.getValue) {
						initVal = Math.round(
							currentVrm.blendShapeProxy.getValue(name) * 100
						);
					} else {
						currentVrm.scene.traverse(obj => {
							if (!obj.isMesh || !obj.morphTargetDictionary || !obj.morphTargetInfluences) return;
							const idx = obj.morphTargetDictionary[name];
							if (idx !== undefined) {
								initVal = Math.round(
									(obj.morphTargetInfluences[idx] || 0) * 100
								);
							}
						});
					}
				} catch (_) {}

				input.value = initVal;

				subcontainer.appendChild(label);
				subcontainer.appendChild(input);
				container.appendChild(subcontainer);
			});
		}
		// #endregion Blend Shape Controls

		// #region Materials
		
		function populateMaterials() {
			const container = document.getElementById('materialsList');
			if (!container) return;

			container.innerHTML = '';

			if (!currentVrm || !currentVrm.scene) {
				container.textContent = 'Load a VRM to list materials.';
				return;
			}

			function isOutlineMaterial(mat) {
				if (!mat || !mat.name) return false;
				return /\(outline\)\s*$/i.test(mat.name);
			}

			const materials = new Map();

			currentVrm.scene.traverse((obj) => {
				if (!obj.isMesh) return;

				const mats = Array.isArray(obj.material)
					? obj.material
					: [obj.material];

				mats.forEach((mat) => {
					if (!mat) return;

					// ignore outline materials
					if (isOutlineMaterial(mat)) return;

					if (!materials.has(mat.uuid)) {
						materials.set(mat.uuid, {
							material: mat,
							meshes: []
						});
					}

					materials.get(mat.uuid).meshes.push(obj);
				});
			});

			if (materials.size === 0) {
				container.textContent = 'No materials found in model.';
				return;
			}

			let index = 0;
			const total = materials.size;

			materials.forEach((entry) => {
				const mat = entry.material;
				const meshes = entry.meshes;

				const row = document.createElement('div');
				row.className = 'setting switch-wrapper';

				if (index === 0) row.classList.add('top');
				if (index === total - 1) row.classList.add('bottom');
				index++;

				/* Thumbnail */
				const thumb = document.createElement('img');
				thumb.style.width = '64px';
				thumb.style.height = '64px';
				thumb.style.borderRadius = '4px';
				thumb.style.objectFit = 'cover';
				thumb.style.cursor = 'pointer';
				thumb.alt = 'no texture';
				thumb.title = mat.name || mat.uuid;

				const mainMap = mat.map || mat.baseMap || null;
				let fullImageDataURL = null;

				if (mainMap && mainMap.image) {
					try {
						const img = mainMap.image;

						const fullCanvas = document.createElement('canvas');
						fullCanvas.width = img.width || 1024;
						fullCanvas.height = img.height || 1024;
						const fctx = fullCanvas.getContext('2d');
						fctx.drawImage(img, 0, 0, fullCanvas.width, fullCanvas.height);
						fullImageDataURL = fullCanvas.toDataURL('image/png');

						const previewCanvas = document.createElement('canvas');
						previewCanvas.width = 128;
						previewCanvas.height = 128;
						const pctx = previewCanvas.getContext('2d');
						pctx.drawImage(img, 0, 0, 128, 128);
						thumb.src = previewCanvas.toDataURL('image/png');
					} catch {
						thumb.alt = 'preview unavailable';
					}
				}

				thumb.addEventListener('click', () => {
					if (!fullImageDataURL) return;

					const img = document.createElement('img');
					img.src = fullImageDataURL;
					img.style.maxWidth = '100%';
					img.style.maxHeight = '100%';
					img.style.display = 'block';
					img.title = mat.name || mat.uuid;

					const safeName = (mat.name || mat.uuid).replace(/"/g, '');

					const toolbarLeft = `
						<button class="icon-button" title="Download" onclick="
							const a=document.createElement('a');
							a.href='${fullImageDataURL}';
							a.download='${safeName}.png';
							a.click();
						">
							Download
						</button>
					`;

					promptMessage(img.outerHTML, true, false, toolbarLeft);
				});

				row.appendChild(thumb);

				/* Material Name */
				const label = document.createElement('span');
				label.className = 'switch-text';
				label.textContent = mat.name || mat.uuid;
				row.appendChild(label);

				/* Visibility switch */
				const switchLabel = document.createElement('label');
				switchLabel.className = 'switch';

				const checkbox = document.createElement('input');
				checkbox.type = 'checkbox';
				checkbox.checked = meshes.some(m => m.visible);

				checkbox.addEventListener('change', () => {
					const visible = checkbox.checked;
					meshes.forEach(mesh => {
						mesh.visible = visible;
					});
				});

				const slider = document.createElement('span');
				slider.className = 'slider';

				switchLabel.appendChild(checkbox);
				switchLabel.appendChild(slider);
				row.appendChild(switchLabel);

				container.appendChild(row);
			});
		}

		// #endregion Materials

		// #region Animation Loop
		// --- Animation Loop ---
		const clock = new THREE.Clock();

		function animate() {
			requestAnimationFrame(animate);

			const deltaTime = clock.getDelta();

			// Update look controls (joystick / follow camera)
			try { updateLookControl(deltaTime); } catch (e) { /* ignore if not initialized */ }

			// Update VRM and AnimationMixer
			if (currentVrm) {
				currentVrm.update(deltaTime);
			}
			if (currentMixer) {
				currentMixer.update(deltaTime);
			}

			// Keep shadow centered under the current VRM on the ground
			if (groundShadow && currentVrm && currentVrm.scene) {
				groundShadow.position.x = currentVrm.scene.position.x;
				groundShadow.position.z = currentVrm.scene.position.z;
			}

			controls.update(); // Update orbit controls
			renderer.render(scene, camera);
		}

		// Start the animation loop
		animate();
		// #endregion Animation Loop

		// #region Initial Load
		// --- Initial Load ---
		// Load the fixed VRM model when the page loads
		window.addEventListener('DOMContentLoaded', async () => {
			// Try to restore a previously loaded VRM from localStorage.
			const restored = await loadLastVrmFromStorage();
			if (!restored) {
				await loadVRM(VRM_MODEL_URL, 'default.vrm');
			}
			await loadVRMA(VRMA_ANIMATIONS['Standard'], 'Standard.vrma');
			if (animationSelect) animationSelect.value = 'Standard';
			updateButtons(); // Update button states after VRM is loaded
			if (!isMobile()) document.getElementById('controls-bar').classList.add('show');
		});
		// #endregion Initial Load

		// const SPRING_JUMP_FORCE = 0.01;

		// window.addEventListener('pointerdown', () => {
		// 	if (!currentVrm?.springBoneManager?._joints) return;

		// 	for (const joint of currentVrm.springBoneManager._joints) {
		// 		if (!joint._prevTail) continue;

		// 		joint._prevTail.y -= SPRING_JUMP_FORCE;
		// 	}

		// 	console.log('Spring jump applied');
		// });

	</script>

	<script>
		const statusBar = document.getElementById('status');

		// #region settings

		function loadSettings() {
			// theme
			const theme = Settings.getSetting("theme");
			if (theme) document.body.className = theme;
			if (Settings.getSetting("theme") === "theme-custom") {
				applyCustomTheme(Settings.getSetting("theme-custom-value", ""));
			}

			// status bar
			if (Settings.getSetting("statusShow", "true") != "true") statusBar.classList.remove('show');
			else statusBar.classList.add('show');
		}

		loadSettings();

		function applyCustomTheme(cssText) {
			let styleEl = document.getElementById("custom-theme-style");
			if (!styleEl) {
				styleEl = document.createElement("style");
				styleEl.id = "custom-theme-style";
				document.head.appendChild(styleEl);
			}
			styleEl.textContent = `.theme-custom { ${cssText} }`;
		}

		// #endregion settings
	</script>
</body>

</html>